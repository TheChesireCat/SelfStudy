<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>catCafe</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext x='12' y='48' font-size='48'%3E%F0%9F%90%B1%3C/text%3E%3C/svg%3E">
    <script src="https://tts.rocks/tts.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs@0.3/dist/epub.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/minisearch@7.2.0/dist/umd/index.min.js" defer></script>
    
    <!-- PDF.js Viewer CSS -->
    <link href="https://cdn.jsdelivr.net/npm/pdf.js-viewer@0.2.8/viewer.min.css" rel="stylesheet">
    
    <style>
        /* Minimal dual-theme tokens shared with viewer */
        :root {
            --theme-surface: #f8f9fb;
            --theme-panel: #ffffff;
            --theme-muted: #eef1f5;
            --theme-border: #d7dce3;
            --theme-text: #0f172a;
            --theme-text-muted: #475569;
            --theme-accent: #2563eb;
            --theme-accent-foreground: #f8fafc;
            --theme-overlay: rgba(15, 23, 42, 0.55);
            --theme-shadow-soft: 0 12px 32px rgba(15, 23, 42, 0.08);
            --theme-radius: 10px;
            --theme-focus: 0 0 0 2px rgba(37, 99, 235, 0.35);
            --theme-focus-strong: 0 0 0 2px rgba(96, 165, 250, 0.5);
        }

        :root[data-theme="light"],
        :root.is-light {
            --theme-surface: #f8f9fb;
            --theme-panel: #ffffff;
            --theme-muted: #eef1f5;
            --theme-border: #d7dce3;
            --theme-text: #0f172a;
            --theme-text-muted: #475569;
            --theme-accent: #2563eb;
            --theme-accent-foreground: #f8fafc;
            --theme-overlay: rgba(15, 23, 42, 0.55);
            --theme-shadow-soft: 0 12px 32px rgba(15, 23, 42, 0.08);
            --theme-focus: 0 0 0 2px rgba(37, 99, 235, 0.35);
            --theme-focus-strong: 0 0 0 2px rgba(37, 99, 235, 0.5);
        }

        :root[data-theme="dark"],
        :root.is-dark {
            --theme-surface: #0b0f19;
            --theme-panel: #111827;
            --theme-muted: #1f2937;
            --theme-border: #2e384d;
            --theme-text: #e5e7eb;
            --theme-text-muted: #9ca3af;
            --theme-accent: #94a3b8;
            --theme-accent-foreground: #0b0f19;
            --theme-overlay: rgba(0, 0, 0, 0.7);
            --theme-shadow-soft: 0 12px 32px rgba(0, 0, 0, 0.45);
            --theme-focus: 0 0 0 2px rgba(148, 163, 184, 0.45);
            --theme-focus-strong: 0 0 0 2px rgba(148, 163, 184, 0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow: hidden;
            color: var(--theme-text);
            background: var(--theme-surface);
            transition: background 0.2s ease, color 0.2s ease;
        }

        .app-shell {
            display: grid;
            grid-template-columns: 280px 1fr 260px;
            grid-template-rows: 1fr;
            grid-template-areas: "sidebar reader tools";
            height: 100vh;
            width: 100%;
            flex: 1 1 auto;
        }

        @media (min-width: 768px) {
            body.sidebar-hidden .app-shell {
                grid-template-columns: 1fr 260px;
                grid-template-areas: "reader tools";
            }

            body.tools-pane-hidden .app-shell {
                grid-template-columns: 280px 1fr;
                grid-template-areas: "sidebar reader";
            }

            body.sidebar-hidden.tools-pane-hidden .app-shell {
                grid-template-columns: 1fr;
                grid-template-areas: "reader";
            }

            body.tools-pane-hidden #tools-pane {
                display: none;
            }
        }

        .pane {
            background: var(--theme-panel);
            min-height: 0;
        }

        .pane-left {
            grid-area: sidebar;
            border-right: 1px solid var(--theme-border);
        }

        .pane-right {
            grid-area: tools;
            border-left: 1px solid var(--theme-border);
            box-shadow: var(--theme-shadow-soft);
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding: 16px;
            overflow-y: auto;
            min-height: 0;
        }

        #reader-pane {
            grid-area: reader;
            display: flex;
            flex-direction: column;
            min-width: 0;
            background: var(--theme-surface);
            position: relative;
            min-height: 0;
        }

        .reader-topbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--theme-panel);
            border-bottom: 1px solid var(--theme-border);
            position: sticky;
            top: 0;
            z-index: 30;
        }

        .reader-topbar-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            background: var(--theme-muted);
            color: var(--theme-text);
            border: 1px solid var(--theme-border);
            font-weight: 600;
            font-size: 13px;
            cursor: default;
        }

        .pill.primary {
            cursor: pointer;
            background: var(--theme-accent);
            color: var(--theme-accent-foreground);
            border-color: var(--theme-accent);
            box-shadow: 0 10px 22px rgba(37, 99, 235, 0.25);
            transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease, color 0.2s ease;
        }

        .pill.primary:disabled {
            background: var(--theme-muted);
            color: var(--theme-text-muted);
            border-color: var(--theme-border);
            box-shadow: none;
            cursor: not-allowed;
        }

        .pill.ghost {
            cursor: pointer;
            background: transparent;
            border-color: var(--theme-border);
        }

        .tools-card {
            background: var(--theme-panel);
            border: 1px solid var(--theme-border);
            border-radius: var(--theme-radius);
            padding: 14px 14px 16px;
            box-shadow: var(--theme-shadow-soft);
            margin-bottom: 8px;
        }

        .tools-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 10px;
        }

        .tools-card-title {
            font-weight: 700;
            color: var(--theme-text);
        }

        .tools-card-subtitle {
            font-size: 13px;
            color: var(--theme-text-muted);
        }

        .tools-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        .muted-text {
            color: var(--theme-text-muted);
            font-size: 13px;
            line-height: 1.5;
        }

        /* Sidebar Styles */
        #sidebar {
            width: 280px;
            background: var(--theme-panel);
            border-right: 1px solid var(--theme-border);
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
            overflow: hidden;
            flex-shrink: 0;
            transition: transform 0.25s ease;
        }

        body.sidebar-hidden #sidebar {
            display: none;
        }

        #header {
            padding: 20px;
            background: var(--theme-panel);
            color: var(--theme-text);
            border-bottom: 1px solid var(--theme-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        #header .header-text {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #header h1 {
            font-size: 22px;
            margin-bottom: 2px;
            font-family: "SFMono-Regular", "Menlo", "Consolas", "Liberation Mono", monospace;
            letter-spacing: 0.01em;
        }

        #header p {
            font-size: 13px;
            color: var(--theme-text-muted);
        }

        .theme-toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 999px;
            border: 1px solid var(--theme-border);
            background: var(--theme-muted);
            color: var(--theme-text);
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            box-shadow: var(--theme-shadow-soft);
            transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
        }

        .theme-toggle.toggled {
            background: var(--theme-accent);
            color: var(--theme-accent-foreground);
            border-color: var(--theme-accent);
            box-shadow: 0 10px 26px rgba(37, 99, 235, 0.25);
        }

        .theme-toggle:focus-visible {
            outline: none;
            box-shadow: var(--theme-focus-strong);
            transform: translateY(-1px);
        }

        .theme-toggle.alt {
            padding: 6px 10px;
        }

        #file-tree {
            padding: 15px;
            flex: 1 1 0;
            min-height: 0;
            overflow-y: auto;
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
            background: var(--theme-panel);
            margin-top: 8px;
            scrollbar-gutter: stable;
        }

        #library-search {
            padding: 10px 15px 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex-shrink: 0;
        }

        .library-search-input {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 999px;
            border: 1px solid var(--theme-border);
            background: var(--theme-muted);
            box-shadow: var(--theme-shadow-soft);
            transition: box-shadow 0.2s ease, border-color 0.2s ease;
        }

        .library-search-input:focus-within {
            border-color: var(--theme-accent);
            box-shadow: var(--theme-focus);
        }

        #library-search-input {
            border: none;
            background: transparent;
            color: var(--theme-text);
            font-size: 13px;
            width: 100%;
            outline: none;
        }

        #library-search-input::placeholder {
            color: var(--theme-text-muted);
        }

        #library-search-clear {
            border: none;
            background: transparent;
            color: var(--theme-text-muted);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, color 0.2s ease;
        }

        #library-search-clear.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #library-search-clear:hover {
            color: var(--theme-text);
        }

        #library-search-status {
            font-size: 12px;
            color: var(--theme-text-muted);
            min-height: 16px;
        }

        .search-hidden {
            display: none !important;
        }

        body.search-active .category-content.search-match,
        body.search-active .file-list.search-match {
            display: block;
        }

        .category {
            margin-bottom: 10px;
        }

        .category-header {
            padding: 8px 10px;
            cursor: pointer;
            border-radius: 6px;
            display: flex;
            align-items: center;
            font-weight: 600;
            color: var(--theme-text);
            background: var(--theme-muted);
            font-size: 13px;
            transition: background 0.2s;
        }

        .category-header:hover {
            background: var(--theme-border);
        }

        .category-icon {
            margin-right: 8px;
            font-size: 16px;
        }

        .category-content {
            margin-left: 15px;
            margin-top: 5px;
            display: none;
            padding-left: 10px;
            border-left: 2px solid var(--theme-border);
        }

        .category-content.open {
            display: block;
        }

        .subcategory {
            margin-bottom: 8px;
        }

        .subcategory-header {
            padding: 6px 10px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: 500;
            font-size: 12px;
            color: var(--theme-text);
            transition: background 0.2s;
        }

        .subcategory-header:hover {
            background: var(--theme-muted);
        }

        .file-list {
            margin-left: 10px;
            margin-top: 3px;
            display: none;
        }

        .file-list.open {
            display: block;
        }

        .file {
            padding: 6px 10px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            font-size: 13px;
            color: var(--theme-text-muted);
            transition: all 0.2s;
            margin: 2px 0;
        }

        .file:hover {
            background: var(--theme-muted);
            color: var(--theme-text);
        }

        .file.selected {
            background: var(--theme-accent);
            color: var(--theme-accent-foreground);
            font-weight: 500;
        }

        .file-icon {
            margin-right: 6px;
            font-size: 12px;
        }

        
        #bookmark-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 0;
            background: transparent;
            flex-shrink: 0;
            margin-top: 8px;
        }

        #bookmark-controls .bookmark-header {
            font-weight: 600;
            color: var(--theme-text);
            font-size: 14px;
        }

        .bookmark-button {
            padding: 6px 10px;
            border: 1px solid var(--theme-border);
            border-radius: 4px;
            background: var(--theme-muted);
            color: var(--theme-text);
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s, color 0.2s, border-color 0.2s;
            text-align: left;
        }

        .bookmark-button:hover:not(:disabled) {
            background: var(--theme-accent);
            color: var(--theme-accent-foreground);
            border-color: var(--theme-accent);
        }

        .bookmark-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #bookmark-status {
            font-size: 13px;
            color: var(--theme-accent);
            min-height: 1em;
            transition: opacity 0.2s ease;
            opacity: 0;
        }

        #bookmark-status.visible {
            opacity: 1;
        }

        #bookmark-status:not(.visible) {
            pointer-events: none;
        }

        .tts-speed-control {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 10px;
            border: 1px solid var(--theme-border);
            border-radius: 8px;
            background: var(--theme-muted);
        }

        .tts-speed-control label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: var(--theme-text);
            font-weight: 600;
        }

        #tts-speed-value {
            font-size: 12px;
            color: var(--theme-accent);
        }

        #tts-speed-slider {
            width: 100%;
            accent-color: var(--theme-accent);
        }

        #tts-overlay {
            position: fixed;
            right: 24px;
            bottom: 24px;
            width: 280px;
            background: var(--theme-panel);
            color: var(--theme-text);
            border-radius: 14px;
            box-shadow: var(--theme-shadow-soft);
            padding: 16px 18px;
            display: none;
            flex-direction: column;
            gap: 12px;
            z-index: 1200;
            backdrop-filter: blur(12px);
            border: 1px solid var(--theme-border);
        }

        #tts-overlay.show {
            display: flex;
        }

        .tts-overlay-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.02em;
        }

        .tts-overlay-meta {
            font-size: 12px;
            color: var(--theme-text-muted);
        }

        .tts-overlay-progress {
            position: relative;
            width: 100%;
            height: 8px;
            background: var(--theme-muted);
            border-radius: 999px;
            overflow: visible;
        }

        .tts-overlay-progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(135deg, var(--theme-accent) 0%, #a855f7 100%);
            border-radius: inherit;
            transition: width 0.2s ease;
        }

        #tts-overlay-scrubber {
            position: absolute;
            left: 0;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 100%;
            height: 20px;
            margin: 0;
            background: transparent;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
        }

        #tts-overlay-scrubber:focus {
            outline: none;
        }

        #tts-overlay-scrubber::-webkit-slider-runnable-track {
            height: 8px;
            background: transparent;
            border-radius: 999px;
        }

        #tts-overlay-scrubber::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 999px;
            background: var(--theme-accent);
            border: 2px solid var(--theme-panel);
            box-shadow: var(--theme-shadow-soft);
            margin-top: -3px;
        }

        #tts-overlay-scrubber::-moz-range-track {
            height: 8px;
            background: transparent;
            border-radius: 999px;
        }

        #tts-overlay-scrubber::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 999px;
            background: var(--theme-accent);
            border: 2px solid var(--theme-panel);
            box-shadow: var(--theme-shadow-soft);
        }

        #tts-overlay-scrubber:disabled {
            cursor: not-allowed;
            opacity: 0.45;
        }

        .tts-overlay-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
        }

        .tts-overlay-button {
            width: 36px;
            height: 36px;
            border-radius: 999px;
            border: 1px solid var(--theme-border);
            background: var(--theme-muted);
            color: var(--theme-text);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tts-overlay-button svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .tts-overlay-button.primary {
            width: 44px;
            height: 44px;
            background: var(--theme-accent);
            border-color: var(--theme-accent);
            color: var(--theme-accent-foreground);
            box-shadow: 0 12px 26px rgba(37, 99, 235, 0.28);
        }

        .tts-overlay-button.primary svg {
            width: 20px;
            height: 20px;
        }

        .tts-overlay-button:hover:not(:disabled) {
            background: linear-gradient(135deg, var(--theme-accent) 0%, #3b82f6 100%);
            color: var(--theme-accent-foreground);
            border-color: var(--theme-accent);
            transform: translateY(-1px);
        }

        .tts-overlay-button.primary:hover:not(:disabled) {
            box-shadow: 0 14px 30px rgba(37, 99, 235, 0.3);
        }

        .tts-overlay-button:disabled {
            background: var(--theme-muted);
            color: var(--theme-text-muted);
            border-color: var(--theme-border);
            box-shadow: none;
            cursor: not-allowed;
            opacity: 0.6;
        }

        #tts-overlay-play[data-state="paused"] .icon-pause,
        #tts-overlay-play[data-state="playing"] .icon-play {
            display: none;
        }

        .tts-overlay-time {
            font-variant-numeric: tabular-nums;
        }

        /* PDF Viewer Container */
        #viewer-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            background: var(--theme-surface);
            min-height: 0;
            width: 100%;
        }

        #pdfjs-viewer {
            width: 100%;
            height: 100%;
        }

        #external-viewer {
            width: 100%;
            height: 100%;
            border: 0;
            background: var(--theme-panel);
        }

        #ebook-viewer {
            display: none;
            flex: 1;
            flex-direction: column;
            min-height: 0;
            background: var(--theme-panel);
            border: 1px solid var(--theme-border);
            border-radius: var(--theme-radius);
            overflow: hidden;
            box-shadow: var(--theme-shadow-soft);
        }

        #ebook-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 10px 12px;
            background: var(--theme-muted);
            border-bottom: 1px solid var(--theme-border);
        }

        #ebook-title {
            font-weight: 700;
            font-size: 14px;
            color: var(--theme-text);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .ebook-meta {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 12px;
            color: var(--theme-text-muted);
        }

        .ebook-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ebook-button {
            border: 1px solid var(--theme-border);
            background: var(--theme-panel);
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            color: var(--theme-text);
            transition: background 0.2s ease, border-color 0.2s ease, transform 0.15s ease;
        }

        .ebook-button:hover:not(:disabled) {
            background: var(--theme-muted);
            transform: translateY(-1px);
        }

        .ebook-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        #ebook-status {
            font-size: 12px;
            color: var(--theme-text-muted);
        }

        #ebook-container {
            flex: 1;
            min-height: 0;
            width: 100%;
            overflow: auto;
            background: var(--theme-panel);
        }

        #placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            background: var(--theme-muted);
            color: var(--theme-text-muted);
        }

        #placeholder-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.6;
        }

        #placeholder-text {
            font-size: 18px;
        }

        #sidebar-toggle {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border: 1px solid var(--theme-border);
            border-radius: 10px;
            background: var(--theme-muted);
            color: var(--theme-text);
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            box-shadow: var(--theme-shadow-soft);
            transition: background 0.2s ease, border-color 0.2s ease, transform 0.15s ease;
        }

        #sidebar-toggle:hover {
            background: var(--theme-panel);
        }

        #tts-floating-controls {
            position: absolute;
            top: calc(24px + env(safe-area-inset-top, 0px));
            right: calc(24px + env(safe-area-inset-right, 0px));
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 12px;
            z-index: 1100;
            pointer-events: none;
            width: clamp(220px, 28vw, 420px);
        }

        #tts-status-banner {
            display: none;
            flex-direction: column;
            align-items: stretch;
            gap: 8px;
            padding: 8px 18px;
            border-radius: 999px;
            background: var(--theme-panel);
            color: var(--theme-text);
            border: 1px solid var(--theme-border);
            font-size: 13px;
            font-weight: 500;
            pointer-events: none;
            box-shadow: var(--theme-shadow-soft);
            transition: opacity 0.2s ease;
            max-width: 100%;
            width: 100%;
            text-align: left;
        }

        #tts-status-banner.visible {
            display: flex;
        }

        #tts-status-banner[data-variant="success"] {
            background: rgba(34, 197, 94, 0.12);
            color: var(--theme-text);
            border-color: rgba(34, 197, 94, 0.35);
        }

        #tts-status-banner[data-variant="error"] {
            background: rgba(239, 68, 68, 0.12);
            color: var(--theme-text);
            border-color: rgba(239, 68, 68, 0.4);
        }

        .tts-status-spinner {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid rgba(248, 250, 252, 0.5);
            border-top-color: #f8fafc;
            animation: spin 0.8s linear infinite;
            display: none;
        }

        #tts-status-banner.busy .tts-status-spinner {
            display: inline-block;
        }

        .tts-status-line {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tts-status-progress {
            width: 100%;
            height: 6px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.16);
            overflow: hidden;
            margin-top: 6px;
            display: none;
        }

        .tts-status-progress-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #8b5cf6 0%, #6366f1 100%);
            transition: width 0.25s ease;
        }

        #tts-status-banner[data-show-progress="true"] .tts-status-progress {
            display: block;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        #sidebar-backdrop {
            display: none;
        }

        #tools-pane {
            width: 260px;
            height: 100%;
        }

        #tools-bottom-bar {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: calc(12px + env(safe-area-inset-bottom, 0px));
            display: none;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 999px;
            background: var(--theme-panel);
            border: 1px solid var(--theme-border);
            box-shadow: var(--theme-shadow-soft);
            z-index: 1200;
        }

        body.tools-sheet-open #tools-bottom-bar {
            opacity: 0;
            pointer-events: none;
        }

        body.tools-bottom-bar-hidden #tools-bottom-bar {
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, 16px);
        }

        #tools-bottom-bubble {
            position: fixed;
            left: 12px;
            bottom: calc(12px + env(safe-area-inset-bottom, 0px));
            width: 44px;
            height: 44px;
            border-radius: 999px;
            display: none;
            align-items: center;
            justify-content: center;
            background: var(--theme-panel);
            color: var(--theme-text);
            border: 1px solid var(--theme-border);
            box-shadow: var(--theme-shadow-soft);
            font-weight: 600;
            font-size: 12px;
            z-index: 1200;
            cursor: pointer;
        }

        body.tools-sheet-open #tools-bottom-bubble {
            opacity: 0;
            pointer-events: none;
        }

        #shortcuts-backdrop {
            position: fixed;
            inset: 0;
            background: var(--theme-overlay);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1400;
        }

        #shortcuts-backdrop.visible {
            opacity: 1;
            pointer-events: all;
        }

        #shortcuts-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.98);
            width: min(420px, 92vw);
            background: var(--theme-panel);
            color: var(--theme-text);
            border: 1px solid var(--theme-border);
            border-radius: 16px;
            box-shadow: 0 24px 60px rgba(15, 23, 42, 0.3);
            padding: 18px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            z-index: 1410;
        }

        #shortcuts-modal.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }

        .shortcuts-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
        }

        .shortcuts-title {
            font-weight: 700;
            font-size: 16px;
        }

        .shortcuts-close {
            border: 1px solid var(--theme-border);
            background: var(--theme-muted);
            color: var(--theme-text);
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
        }

        .shortcuts-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-size: 13px;
        }

        .shortcuts-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .shortcuts-keys {
            display: inline-flex;
            gap: 6px;
            align-items: center;
            font-family: "SFMono-Regular", "Menlo", "Consolas", "Liberation Mono", monospace;
        }

        .shortcuts-keys kbd {
            padding: 2px 6px;
            border-radius: 6px;
            border: 1px solid var(--theme-border);
            background: var(--theme-muted);
            font-size: 12px;
        }

        #tools-bottom-bar button {
            border: none;
            background: transparent;
            color: var(--theme-text);
            font-size: 18px;
            padding: 6px 10px;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        #tools-bottom-bar .text-button {
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.01em;
        }

        #tools-bottom-bar button:hover:not(:disabled) {
            background: var(--theme-muted);
        }

        #tools-sheet-backdrop {
            position: fixed;
            inset: 0;
            background: var(--theme-overlay);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1190;
            display: none;
        }

        @media (max-width: 1023px) {
            .app-shell {
                grid-template-columns: 1fr 240px;
                grid-template-areas: "reader tools";
            }

            #sidebar {
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                height: 100dvh;
                width: 280px;
                transform: translateX(-100%);
                border-right: none;
                border-bottom: none;
                box-shadow: 2px 0 16px rgba(0, 0, 0, 0.25);
                z-index: 1300;
                overflow: hidden;
                display: none;
            }

            #sidebar.open {
                display: flex;
                transform: translateX(0);
            }

            #sidebar-backdrop {
                position: fixed;
                inset: 0;
                background: var(--theme-overlay);
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.25s ease;
                display: block;
                z-index: 1200;
            }

            #sidebar-backdrop.visible {
                opacity: 1;
                pointer-events: all;
            }

            #file-tree {
                padding-bottom: calc(24px + env(safe-area-inset-bottom, 0px));
            }
        }

        @media (max-width: 767px) {
            .app-shell {
                grid-template-columns: 1fr;
                grid-template-areas: "reader";
            }

            #tools-pane {
                position: fixed;
                left: 0;
                right: 0;
                bottom: 0;
                width: 100%;
                max-height: 75vh;
                transform: translateY(100%);
                border-left: none;
                border-right: none;
                border-top: 1px solid var(--theme-border);
                box-shadow: 0 -18px 32px rgba(15, 23, 42, 0.25);
                z-index: 1290;
                background: var(--theme-panel);
                transition: transform 0.25s ease;
                display: none;
            }

            body.tools-sheet-open #tools-pane {
                transform: translateY(0);
                display: flex;
            }

            #tools-bottom-bar {
                display: inline-flex;
            }

            body.tools-bottom-bar-hidden #tools-bottom-bubble {
                display: inline-flex;
            }

            #tools-sheet-backdrop {
                display: block;
            }

            body.tools-sheet-open #tools-sheet-backdrop {
                opacity: 1;
                pointer-events: all;
            }

            #tools-pane .tools-card {
                margin-bottom: 12px;
            }
        }

    </style>
</head>

<body>
    <div class="app-shell">
        <aside id="sidebar" class="pane pane-left">

            <div id="header">
                <div class="header-text">
                    <h1>üê± catCafe</h1>
                    <p style="font-family: 'SFMono-Regular', 'Menlo', 'Consolas', 'Liberation Mono', monospace;">walruses hubs whiskers knots; complex systems network science and beyond</p>
                </div>
            </div>
            <div id="library-search">
                <div class="library-search-input">
                    <input id="library-search-input" type="search" aria-label="Search library" placeholder="Search titles, categories, or subcategories" autocomplete="off">
                    <button id="library-search-clear" type="button" aria-label="Clear search">Clear</button>
                </div>
                <div id="library-search-status">Type to filter the library.</div>
            </div>
            <div id="file-tree">
            <!-- 01-Foundations -->
            <div class="category">
                <div class="category-header" onclick="toggleCategory(this)">
                    <span class="category-icon">üìÅ</span>
                    <span>01-Foundations</span>
                </div>
                <div class="category-content">
                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            Mathematics
                        </div>
                        <div class="file-list">
                            <div class="subcategory-header" onclick="toggleSubcategory(this)" style="margin-left: 10px;">
                                Calculus
                            </div>
                            <div class="file-list" style="margin-left: 20px;">
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Mathematics/Calculus/Crash-Course-in-Vector-Calculus.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Crash Course in Vector Calculus</span>
                                </div>
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Mathematics/Calculus/Single-and-Multivariable-Calculus-Early-Transcendentals.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Single & Multivariable Calculus</span>
                                </div>
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Mathematics/Calculus/Differential-Equations-An-Introduction-for-Engineers-Matthew-Charnley.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Differential Equations: An Introduction for Engineers</span>
                                </div>
                            </div>

                            <div class="subcategory-header" onclick="toggleSubcategory(this)" style="margin-left: 10px;">
                                Linear Algebra
                            </div>
                            <div class="file-list" style="margin-left: 20px;">
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Mathematics/Linear-Algebra/Linear-Algebra-and-Multivariable-Calculus-Chen-MIT-18.02.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Linear Algebra - MIT 18.02 (Chen)</span>
                                </div>
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Mathematics/Linear-Algebra/Linear-Algebra-Cherney-Denton-Thomas-Waldron.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Linear Algebra (Cherney et al.)</span>
                                </div>
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Mathematics/Linear-Algebra/Topics-in-Random-Matrix-Theory-Tao.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Random Matrix Theory (Tao)</span>
                                </div>
                            </div>

                            <div class="subcategory-header" onclick="toggleSubcategory(this)" style="margin-left: 10px;">
                                Probability & Statistics
                            </div>
                            <div class="file-list" style="margin-left: 20px;">
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Mathematics/Probability-Statistics/All-of-Statistics-Wasserman-2004.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>All of Statistics (Wasserman)</span>
                                </div>
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Mathematics/Probability-Statistics/Introduction-to-Econometrics-Stock-Watson-2020.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Econometrics (Stock & Watson)</span>
                                </div>
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Mathematics/Probability-Statistics/Introduction-to-Mathematical-Statistics-8th-Ed-Hogg.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Mathematical Statistics (Hogg)</span>
                                </div>
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Mathematics/Probability-Statistics/Introduction-to-Probability-Models-Ross.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Probability Models (Ross)</span>
                                </div>
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Mathematics/Probability-Statistics/Introduction-to-Probability-and-Statistics-Mendenhall-Beaver.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Probability & Statistics (Mendenhall)</span>
                                </div>
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Mathematics/Probability-Statistics/Probability-Cheatsheet-CME106-Amidi.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Probability Cheatsheet (CME106)</span>
                                </div>
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Mathematics/Probability-Statistics/Statistics-Cheatsheet-CME106-Amidi.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Statistics Cheatsheet (CME106)</span>
                                </div>
                            </div>

                            <div class="subcategory-header" onclick="toggleSubcategory(this)" style="margin-left: 10px;">
                                Numerical Methods
                            </div>
                            <div class="file-list" style="margin-left: 20px;">
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Mathematics/Numerical-Methods/Numerical-Recipes-Press-et-al-2007.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Numerical Recipes (Press et al.)</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            Computer Science
                        </div>
                        <div class="file-list">
                            <div class="subcategory-header" onclick="toggleSubcategory(this)" style="margin-left: 10px;">
                                Algorithms
                            </div>
                            <div class="file-list" style="margin-left: 20px;">
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Computer-Science/Algorithms/Introduction-to-Algorithms-4th-Ed-CLRS.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Introduction to Algorithms (CLRS)</span>
                                </div>
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Computer-Science/Algorithms/%28KT%29%20Algorithm%20Design%20by%20Jon%20Kleinberg%2C%20Eva%20Tardos.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Algorithm Design (Kleinberg &amp; Tardos)</span>
                                </div>
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Computer-Science/Algorithms/Algorithms-JeffE.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Algorithms (Jeff Erickson)</span>
                                </div>
                            </div>

                            <div class="subcategory-header" onclick="toggleSubcategory(this)" style="margin-left: 10px;">
                                System Design
                            </div>
                            <div class="file-list" style="margin-left: 20px;">
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Computer-Science/System-Design/System-Design-Interview-Xu.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>System Design Interview (Xu)</span>
                                </div>
                            </div>

                            <div class="subcategory-header" onclick="toggleSubcategory(this)" style="margin-left: 10px;">
                                Numerical Methods
                            </div>
                            <div class="file-list" style="margin-left: 20px;">
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Computer-Science/Numerical%20Methods/Introduction-to-Computation-and-Programming-Using-Python-Guttag-2nd-Ed-2016.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Intro to Computation &amp; Programming Using Python (Guttag, 2nd Ed)</span>
                                </div>
                                <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Computer-Science/Numerical%20Methods/Numerical-Linear-Algebra-Trefethen-Bau.pdf', this)">
                                    <span class="file-icon">üìÑ</span>
                                    <span>Numerical Linear Algebra (Trefethen &amp; Bau)</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            Physics
                        </div>
                        <div class="file-list">
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Physics/Fundamentals-of-Physics-Extended-10th-Ed-Halliday-Resnick.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Fundamentals of Physics (Halliday &amp; Resnick, 10th Ed)</span>
                            </div>
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Physics/Classical-Mechanics-Leonard-Susskind.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Classical Mechanics (Susskind)</span>
                            </div>
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Physics/Introduction-to-Electrodynamics-Griffiths-1999.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Introduction to Electrodynamics (Griffiths, 1999)</span>
                            </div>
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Physics/Statistical-Mechanics-Daniel-F-Styer.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Statistical Mechanics (Styer)</span>
                            </div>
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/01-Foundations/Physics/The-Road-to-Reality-A-Complete-Guide-to-the-Laws-of-the-Universe-Roger-Penrose-2006.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>The Road to Reality (Penrose, 2006)</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 02-Network-Science -->
            <div class="category">
                <div class="category-header" onclick="toggleCategory(this)">
                    <span class="category-icon">üìÅ</span>
                    <span>02-Network-Science</span>
                </div>
                <div class="category-content">
                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            Graph Theory
                        </div>
                        <div class="file-list">
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/02-Network-Science/Graph-Theory/Graph-Theory-Deo.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Graph Theory (Deo)</span>
                            </div>
                        </div>
                    </div>

                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            Complex Networks
                        </div>
                        <div class="file-list">
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/02-Network-Science/Complex-Networks/Networks-Newman-2018.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Networks (Newman 2018)</span>
                            </div>
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/02-Network-Science/Complex-Networks/Networks-Crowds-and-Markets-Easley-Kleinberg.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Networks, Crowds, Markets</span>
                            </div>
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/02-Network-Science/Complex-Networks/Network-Science-Barabasi.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Network Science (Barab√°si)</span>
                            </div>
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/02-Network-Science/Complex-Networks/Handbook%20of%20Graph%20Drawing%20and%20Visualization_%20Draft%20of%202013%20--%20Tamassia%20R_%20%28Ed_%29%20--%202013%20--%20d6e78ba7a942e1219d1be5b603984547%20--%20Anna%E2%80%99s%20Archive.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Handbook of Graph Drawing & Visualization (Tamassia)</span>
                            </div>
                        </div>
                    </div>

                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            Network Science 2
                        </div>
                        <div class="file-list">
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/02-Network-Science/NETS2%20-%20Complex%20Networks%3A%20Principles%2C%20Methods%20and%20Applications%20%28Latora%2C%20Nicosia%2C%20Russo%29.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>NETS2 - Complex Networks: Principles, Methods and Applications (Latora, Nicosia, Russo)</span>
                            </div>
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/02-Network-Science/NETS2%20-%20Random%20Graphs%20and%20Complex%20Networks%20%28van%20der%20Hofstad%29%20%5BVol%201%5D.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>NETS2 - Random Graphs and Complex Networks (van der Hofstad) [Vol 1]</span>
                            </div>
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/02-Network-Science/NETS2%20-%20Random%20Graphs%20and%20Complex%20Networks%20%28van%20der%20Hofstad%29%20%5BVol%202%5D.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>NETS2 - Random Graphs and Complex Networks (van der Hofstad) [Vol 2]</span>
                            </div>
                        </div>
                    </div>

                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            Machine Learning on Graphs
                        </div>
                        <div class="file-list">
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/02-Network-Science/Machine-Learning-on-Graphs/CS224W-Machine-Learning-with-Graphs-Stanford.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>CS224W (Stanford)</span>
                            </div>
                        </div>
                    </div>

                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            Network Dynamics
                        </div>
                        <div class="file-list">
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/02-Network-Science/Network-Dynamics/Dynamical-Processes-on-Complex-Networks-Barrat-et-al-2008.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Dynamical Processes (Barrat)</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 03-Complex-Systems -->
            <div class="category">
                <div class="category-header" onclick="toggleCategory(this)">
                    <span class="category-icon">üìÅ</span>
                    <span>03-Complex-Systems</span>
                </div>
                <div class="category-content">
                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            Nonlinear Dynamics & Chaos
                        </div>
                        <div class="file-list">
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/03-Complex-Systems/Nonlinear-Dynamics-Chaos/Nonlinear-Dynamics-and-Chaos-Strogatz-2024.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Nonlinear Dynamics (Strogatz)</span>
                            </div>
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/03-Complex-Systems/Nonlinear-Dynamics-Chaos/Nonlinear-Dynamics-and-Chaos-Solutions-Manual-Strogatz-2024.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Solutions Manual (Strogatz)</span>
                            </div>
                        </div>
                    </div>

                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            General Complexity
                        </div>
                        <div class="file-list">
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/03-Complex-Systems/General-Complexity/Modeling-and-Analysis-of-Complex-Systems-Sayama.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Complex Systems (Sayama)</span>
                            </div>
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/03-Complex-Systems/General-Complexity/Introduction-to-the-Theory-of-Complex-Systems-Thurner-Hanel-Klimek-2018.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Introduction to the Theory of Complex Systems (Thurner, Hanel, Klimek)</span>
                            </div>
                        </div>
                    </div>

                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            Urban Science
                        </div>
                        <div class="file-list">
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/03-Complex-Systems/Urban-Science/Introduction-to-Urban-Science-Bettencourt-2021.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Urban Science (Bettencourt)</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 04-Applied-Methods -->
            <div class="category">
                <div class="category-header" onclick="toggleCategory(this)">
                    <span class="category-icon">üìÅ</span>
                    <span>04-Applied-Methods</span>
                </div>
                <div class="category-content">
                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            Epidemiology
                        </div>
                        <div class="file-list">
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/04-Applied-Methods/Epidemiology/Mathematics-of-Epidemics-on-Networks-Kiss-Miller-Simon.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Epidemics on Networks</span>
                            </div>
                        </div>
                    </div>

                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            Research Design
                        </div>
                        <div class="file-list">
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/04-Applied-Methods/Research-Design/Research-Design-and-Methods-Bordens-Abbott-2022.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Research Design & Methods</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 05-General-Reading -->
            <div class="category">
                <div class="category-header" onclick="toggleCategory(this)">
                    <span class="category-icon">üìÅ</span>
                    <span>05-General-Reading</span>
                </div>
                <div class="category-content">
                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            Popular Science
                        </div>
                        <div class="file-list">
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/05-General-Reading/Complexity-A-Guided-Tour-Mitchell.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Complexity: A Guided Tour</span>
                            </div>
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/05-General-Reading/Scale-West.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>Scale (West)</span>
                            </div>
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/05-General-Reading/The-Feeling-of-Life-Itself-Christof-Koch.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>The Feeling of Life Itself</span>
                            </div>
                            <div class="file" onclick="loadPDF('https://media.githubusercontent.com/media/TheChesireCat/SelfStudy/main/05-General-Reading/The-Nature-of-Computation-Moore-Mertens.pdf', this)">
                                <span class="file-icon">üìÑ</span>
                                <span>The Nature of Computation</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- External Links -->
            <div class="category">
                <div class="category-header" onclick="toggleCategory(this)">
                    <span class="category-icon">üìÅ</span>
                    <span>External Links</span>
                </div>
                <div class="category-content">
                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            Courses & Notes
                        </div>
                        <div class="file-list">
                            <div class="file external-link" onclick="loadExternal('https://arxiv.org/pdf/2404.17625', this)">
                                <span class="file-icon">üåê</span>
                                <span>Alice's Experiments in a Differentiable World (PDF)</span>
                            </div>
                            <div class="file external-link" onclick="loadExternal('https://d2l.ai', this)">
                                <span class="file-icon">üåê</span>
                                <span>Dive Into Deep Learning (site)</span>
                            </div>
                            <div class="file external-link" onclick="loadExternal('https://cosmo-notes.github.io/', this)">
                                <span class="file-icon">üåê</span>
                                <span>COSMO: Complex Systems Modeling</span>
                            </div>
                        </div>
                    </div>
                    <div class="subcategory">
                        <div class="subcategory-header" onclick="toggleSubcategory(this)">
                            Tools & References
                        </div>
                        <div class="file-list">
                            <div class="file external-link" onclick="loadExternal('https://jupyterbook.org/en/stable/intro.html', this)">
                                <span class="file-icon">üß∞</span>
                                <span>jupyter-book</span>
                            </div>
                            <div class="file external-link" onclick="loadExternal('https://quarto.org/docs/books/', this)">
                                <span class="file-icon">üß∞</span>
                                <span>Quarto Books</span>
                            </div>
                            <div class="file external-link" onclick="loadExternal('https://juliadynamics.github.io/JuliaDynamics/', this)">
                                <span class="file-icon">üß∞</span>
                                <span>JuliaDynamics</span>
                            </div>
                            <div class="file external-link" onclick="loadExternal('https://gist.github.com/pourmand1376/aa6a8bc4fddda31fecbdf73b2535af21', this)">
                                <span class="file-icon">üß∞</span>
                                <span>NumPy Cheatsheet</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        </aside>

        <main id="reader-pane">
            <div class="reader-topbar">
                <div class="reader-topbar-left">
                    <button id="sidebar-toggle" type="button" aria-label="Toggle library" aria-controls="sidebar" aria-expanded="false" aria-pressed="false">Library</button>
                </div>
                <div class="reader-topbar-right">
                    <button id="tools-sheet-toggle" type="button" class="pill ghost" aria-label="Toggle tools panel" aria-expanded="false">Tools</button>
                    <button id="shortcuts-toggle" type="button" class="pill ghost" aria-haspopup="dialog" aria-controls="shortcuts-modal" aria-expanded="false">Shortcuts</button>
                    <button id="theme-toggle" class="theme-toggle alt" type="button" aria-pressed="false" aria-label="Toggle theme">
                        <span class="theme-icon" aria-hidden="true">üåó</span>
                        <span class="theme-label">Toggle</span>
                    </button>
                </div>
            </div>
<!-- PDF Viewer Container -->
    <div id="viewer-container">
        <div id="placeholder">
            <div id="placeholder-icon">üìÑ</div>
            <div id="placeholder-text">Select a PDF, EPUB, MOBI, or link from the sidebar to start reading</div>
        </div>
        <iframe id="pdfjs-viewer" style="display: none;" frameborder="0"></iframe>
        <iframe id="external-viewer" style="display: none;" frameborder="0"></iframe>
        <div id="ebook-viewer" role="region" aria-label="EPUB/MOBI viewer" style="display: none;">
            <div id="ebook-toolbar">
                <div id="ebook-title">eBook viewer</div>
                <div class="ebook-meta">
                    <span id="ebook-status">Select an EPUB or MOBI link</span>
                    <div class="ebook-controls">
                        <button id="ebook-prev" type="button" class="ebook-button" disabled>Prev</button>
                        <button id="ebook-next" type="button" class="ebook-button" disabled>Next</button>
                    </div>
                </div>
            </div>
            <div id="ebook-container"></div>
        </div>
                <div id="tts-floating-controls">
                    <div id="tts-status-banner" role="status" aria-live="polite" aria-atomic="true">
                        <div class="tts-status-line">
                            <span class="tts-status-spinner" aria-hidden="true"></span>
                            <span id="tts-status-text"></span>
                        </div>
                        <div class="tts-status-progress" id="tts-status-progress" aria-hidden="true">
                            <div class="tts-status-progress-fill" id="tts-status-progress-fill"></div>
                        </div>
                    </div>
                </div>
    </div>
    
        </main>

        <aside id="tools-pane" class="pane pane-right">
            <div class="tools-card">
                <div class="tools-card-header">
                    <div>
                        <div class="tools-card-title">Bookmarks</div>
                        <div class="tools-card-subtitle">Save or resume your spot</div>
                    </div>
                </div>
<div id="bookmark-controls" role="region" aria-label="Bookmark controls">
            <div class="bookmark-header">Reading Progress</div>
            <button type="button" class="bookmark-button bookmark-save">Bookmark Page</button>
            <button type="button" class="bookmark-button bookmark-resume">Resume Bookmark</button>
            <button type="button" class="bookmark-button bookmark-clear">Clear Bookmark</button>
            <div id="bookmark-status" aria-live="polite"></div>
        </div>
            </div>

            <div class="tools-card">
                <div class="tools-card-header">
                    <div>
                        <div class="tools-card-title">Narration</div>
                        <div class="tools-card-subtitle">Read aloud and control speed</div>
                    </div>
                </div>
                <div class="tools-actions">
                    <button id="tts-read-selection-button-pane" type="button" class="pill primary" aria-label="Read selected text" disabled>Read Selection</button>
                    <button id="tts-read-page-button-pane" type="button" class="pill primary" aria-label="Read current page" disabled>Read Page</button>
                </div>
                <div class="tts-speed-control">
                    <label for="tts-speed-slider">
                        Narration Speed
                        <span id="tts-speed-value">1.0√ó</span>
                    </label>
                    <input type="range" id="tts-speed-slider" min="0.6" max="3" step="0.05" value="1">
                </div>
                <div class="tools-actions" style="margin-top: 6px;">
                    <div class="muted-text">Continuous narration with automatic page turns.</div>
                </div>
            </div>

            <div class="tools-card">
                <div class="tools-card-header">
                    <div>
                        <div class="tools-card-title">Notes & Highlights</div>
                        <div class="tools-card-subtitle">Coming soon</div>
                    </div>
                </div>
                <p class="muted-text">Use your viewer tools to annotate; this panel will aggregate highlights later.</p>
            </div>
        </aside>
    </div>

    <div id="sidebar-backdrop" aria-hidden="true"></div>

    <div id="tools-bottom-bar" role="group" aria-label="Quick reading tools">
        <button id="quick-library-toggle" type="button" class="text-button" aria-label="Toggle library">Library</button>
        <button id="quick-bookmark-save" type="button" aria-label="Bookmark page">üîñ</button>
        <button id="quick-bookmark-resume" type="button" aria-label="Resume bookmark">‚è©</button>
        <button id="quick-tts-read-selection" type="button" aria-label="Read selection">üîä</button>
        <button id="quick-tts-read-page" type="button" aria-label="Read page">üìñ</button>
        <button id="tools-sheet-toggle-mobile" type="button" aria-label="Open tools sheet">‚ãØ</button>
        <button id="tools-bottom-bar-hide" type="button" class="text-button" aria-label="Hide tools bar">Hide</button>
    </div>

    <button id="tools-bottom-bubble" type="button" aria-label="Show tools bar" aria-hidden="true">Tools</button>

    <div id="tools-sheet-backdrop" aria-hidden="true"></div>

    <div id="shortcuts-backdrop" aria-hidden="true"></div>
    <div id="shortcuts-modal" role="dialog" aria-modal="true" aria-label="Keyboard shortcuts" aria-hidden="true">
        <div class="shortcuts-header">
            <div class="shortcuts-title">Keyboard shortcuts</div>
            <button id="shortcuts-close" type="button" class="shortcuts-close">Close</button>
        </div>
        <div class="shortcuts-list">
            <div class="shortcuts-item">
                <span>Toggle library pane</span>
                <span class="shortcuts-keys"><kbd>L</kbd></span>
            </div>
            <div class="shortcuts-item">
                <span>Toggle tools pane</span>
                <span class="shortcuts-keys"><kbd>T</kbd></span>
            </div>
            <div class="shortcuts-item">
                <span>Show shortcuts</span>
                <span class="shortcuts-keys"><kbd>?</kbd><kbd>H</kbd></span>
            </div>
            <div class="shortcuts-item">
                <span>Close dialogs</span>
                <span class="shortcuts-keys"><kbd>Esc</kbd></span>
            </div>
        </div>
    </div>

    <div id="tts-overlay" role="dialog" aria-live="polite" aria-label="Narration player">
        <div class="tts-overlay-header">
            <span id="tts-overlay-title">Narration</span>
            <span class="tts-overlay-time" id="tts-overlay-time">0:00 elapsed ‚Ä¢ 0:00 remaining</span>
        </div>
        <div class="tts-overlay-meta" id="tts-overlay-meta">0 words ‚Ä¢ 1.0√ó</div>
        <div class="tts-overlay-progress">
            <div class="tts-overlay-progress-fill" id="tts-overlay-progress"></div>
            <input type="range" id="tts-overlay-scrubber" min="0" max="0" step="0.1" value="0" aria-label="Seek narration">
        </div>
        <div class="tts-overlay-controls">
            <button type="button" id="tts-overlay-prev" class="tts-overlay-button" aria-label="Previous segment" disabled>
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                    <path d="M6 5h2v14H6z"></path>
                    <path d="M18 5l-8 7 8 7V5z"></path>
                </svg>
            </button>
            <button type="button" id="tts-overlay-play" class="tts-overlay-button primary" aria-label="Pause narration" disabled data-state="paused">
                <svg class="icon-play" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                    <path d="M8 5v14l11-7z"></path>
                </svg>
                <svg class="icon-pause" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                    <rect x="6" y="5" width="4" height="14"></rect>
                    <rect x="14" y="5" width="4" height="14"></rect>
                </svg>
            </button>
            <button type="button" id="tts-overlay-skip" class="tts-overlay-button" aria-label="Next segment" disabled>
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                    <path d="M16 5h2v14h-2z"></path>
                    <path d="M6 5l8 7-8 7V5z"></path>
                </svg>
            </button>
            <button type="button" id="tts-overlay-stop" class="tts-overlay-button" aria-label="Stop narration" disabled>
                <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                    <rect x="6" y="6" width="12" height="12"></rect>
                </svg>
            </button>
        </div>
    </div>

    
<script>
        function toggleCategory(header) {
            const content = header.nextElementSibling;
            content.classList.toggle('open');
            const icon = header.querySelector('.category-icon');
            icon.textContent = content.classList.contains('open') ? 'üìÇ' : 'üìÅ';
        }

        function toggleSubcategory(header) {
            const content = header.nextElementSibling;
            if (content && content.classList.contains('file-list')) {
                content.classList.toggle('open');
            }
        }

        
        const placeholder = document.getElementById('placeholder');
        const viewer = document.getElementById('pdfjs-viewer');
        const externalViewer = document.getElementById('external-viewer');
        const ebookViewer = document.getElementById('ebook-viewer');
        const ebookContainer = document.getElementById('ebook-container');
        const ebookTitle = document.getElementById('ebook-title');
        const ebookStatus = document.getElementById('ebook-status');
        const ebookPrev = document.getElementById('ebook-prev');
        const ebookNext = document.getElementById('ebook-next');
        const sidebar = document.getElementById('sidebar');
        const fileTree = document.getElementById('file-tree');
        const sidebarBackdrop = document.getElementById('sidebar-backdrop');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const toolsPane = document.getElementById('tools-pane');
        const toolsSheetToggle = document.getElementById('tools-sheet-toggle');
        const toolsSheetToggleMobile = document.getElementById('tools-sheet-toggle-mobile');
        const toolsSheetBackdrop = document.getElementById('tools-sheet-backdrop');
        const toolsBottomBar = document.getElementById('tools-bottom-bar');
        const toolsBottomBarHide = document.getElementById('tools-bottom-bar-hide');
        const toolsBottomBubble = document.getElementById('tools-bottom-bubble');
        const libraryToggleMobile = document.getElementById('quick-library-toggle');
        const shortcutsToggle = document.getElementById('shortcuts-toggle');
        const shortcutsModal = document.getElementById('shortcuts-modal');
        const shortcutsBackdrop = document.getElementById('shortcuts-backdrop');
        const shortcutsClose = document.getElementById('shortcuts-close');
        const tabletQuery = window.matchMedia('(max-width: 1023px)');
        const mobileQuery = window.matchMedia('(max-width: 767px)');
        const isFileProtocol = window.location.protocol === 'file:';
        const messageTargetOrigin = isFileProtocol ? '*' : window.location.origin;
        const themeToggleButtons = Array.from(document.querySelectorAll('#theme-toggle'));

        const bookmarkControls = document.getElementById('bookmark-controls');
        const bookmarkSaveButton = bookmarkControls ? bookmarkControls.querySelector('.bookmark-save') : null;
        const bookmarkResumeButton = bookmarkControls ? bookmarkControls.querySelector('.bookmark-resume') : null;
        const bookmarkClearButton = bookmarkControls ? bookmarkControls.querySelector('.bookmark-clear') : null;
        const ttsReadSelectionButton = document.getElementById('tts-read-selection-button-pane');
        const ttsReadPageButton = document.getElementById('tts-read-page-button-pane');
        const quickBookmarkSave = document.getElementById('quick-bookmark-save');
        const quickBookmarkResume = document.getElementById('quick-bookmark-resume');
        const quickTtsSelection = document.getElementById('quick-tts-read-selection');
        const quickTtsPage = document.getElementById('quick-tts-read-page');
        const bookmarkStatus = document.getElementById('bookmark-status');
        const ttsSpeedSlider = document.getElementById('tts-speed-slider');
        const ttsSpeedValue = document.getElementById('tts-speed-value');
        const ttsOverlay = document.getElementById('tts-overlay');
        const ttsOverlayTime = document.getElementById('tts-overlay-time');
        const ttsOverlayTitle = document.getElementById('tts-overlay-title');
        const ttsOverlayMeta = document.getElementById('tts-overlay-meta');
        const ttsOverlayProgress = document.getElementById('tts-overlay-progress');
        const ttsOverlayScrubber = document.getElementById('tts-overlay-scrubber');
        const ttsOverlayPrev = document.getElementById('tts-overlay-prev');
        const ttsOverlayPlay = document.getElementById('tts-overlay-play');
        const ttsOverlaySkip = document.getElementById('tts-overlay-skip');
        const ttsOverlayStop = document.getElementById('tts-overlay-stop');
        const ttsStatusBanner = document.getElementById('tts-status-banner');
        const ttsStatusText = document.getElementById('tts-status-text');
        const ttsStatusProgress = document.getElementById('tts-status-progress');
        const ttsStatusProgressFill = document.getElementById('tts-status-progress-fill');
        const searchInput = document.getElementById('library-search-input');
        const searchClearButton = document.getElementById('library-search-clear');
        const searchStatus = document.getElementById('library-search-status');
        const STORAGE_KEY = 'pdfBookmarks';
        const LAST_DOCUMENT_KEY = 'pdfLastDocument';
        const THEME_STORAGE_KEY = 'pdfjs-theme';
        const TTS_SPEED_KEY = 'ttsNarrationSpeed';
        const DEFAULT_TTS_SPEED = 1;
        const MIN_TTS_SPEED = 0.6;
        const MAX_TTS_SPEED = 3;
        const TTS_SPEED_STEP = 0.05;
        const NARRATION_MAX_WORDS = 150;
        const NARRATION_BUFFER_SIZE = 3;
        const NARRATION_CONTEXT = 'narration';
        const NARRATION_EMPTY_PAGE_LIMIT = 3;
        const AUTO_SAVE_DEBOUNCE_MS = 2000;
        const AUTO_SAVE_IDLE_TIMEOUT_MS = 5000;
        const SIDEBAR_HIDDEN_KEY = 'libraryPaneHidden';
        const TOOLS_PANE_HIDDEN_KEY = 'toolsPaneHidden';
        const TOOLS_BOTTOM_BAR_HIDDEN_KEY = 'toolsBottomBarHidden';

        function getStoredThemePreference() {
            try {
                const stored = localStorage.getItem(THEME_STORAGE_KEY);
                return stored === 'light' || stored === 'dark' ? stored : null;
            } catch (error) {
                console.debug('[theme] Unable to read stored theme', error);
                return null;
            }
        }

        function readStoredBoolean(key, fallback = false) {
            try {
                const stored = localStorage.getItem(key);
                if (stored === null) {
                    return fallback;
                }
                return stored === 'true';
            } catch (error) {
                console.debug('[storage] Unable to read stored flag', key, error);
                return fallback;
            }
        }

        function storeBoolean(key, value) {
            try {
                localStorage.setItem(key, value ? 'true' : 'false');
            } catch (error) {
                console.debug('[storage] Unable to persist flag', key, error);
            }
        }

        function resolveThemePreference() {
            const stored = getStoredThemePreference();
            if (stored) {
                return stored;
            }
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            return prefersDark ? 'dark' : 'light';
        }

        function syncViewerTheme(theme) {
            const applied = theme || document.documentElement.dataset.theme;
            try {
                if (viewer && viewer.contentDocument && viewer.contentDocument.documentElement) {
                    const docEl = viewer.contentDocument.documentElement;
                    docEl.dataset.theme = applied;
                    docEl.classList.toggle('is-dark', applied === 'dark');
                    docEl.classList.toggle('is-light', applied === 'light');
                }
            } catch (error) {
                console.debug('[theme] Unable to sync theme to viewer iframe', error);
            }
        }

        function applyThemePreference(theme, options = {}) {
            const applied = theme === 'dark' ? 'dark' : 'light';
            document.documentElement.dataset.theme = applied;
            document.documentElement.classList.toggle('is-dark', applied === 'dark');
            document.documentElement.classList.toggle('is-light', applied === 'light');
            if (options.syncViewer !== false) {
                syncViewerTheme(applied);
            }
            return applied;
        }

        function persistThemePreference(theme) {
            try {
                localStorage.setItem(THEME_STORAGE_KEY, theme);
            } catch (error) {
                console.debug('[theme] Unable to persist theme', error);
            }
        }

        function syncThemeToggle(theme) {
            themeToggleButtons.forEach(btn => {
                if (!btn) {
                    return;
                }
                const label = btn.querySelector('.theme-label');
                const icon = btn.querySelector('.theme-icon');
                btn.setAttribute('aria-pressed', theme === 'dark' ? 'true' : 'false');
                btn.classList.toggle('toggled', theme === 'dark');
                if (label) {
                    label.textContent = theme === 'dark' ? 'Dark' : 'Light';
                }
                if (icon) {
                    icon.textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
                }
            });
            try {
                if (viewer && viewer.contentDocument) {
                    const toggle = viewer.contentDocument.getElementById('themeToggle');
                    if (toggle) {
                        toggle.style.display = 'none';
                    }
                }
            } catch (error) {
                console.debug('[theme] Unable to hide viewer toggle', error);
            }
        }

        function initThemeControls() {
            const initialTheme = applyThemePreference(resolveThemePreference(), { syncViewer: false });
            syncThemeToggle(initialTheme);
            syncViewerTheme(initialTheme);

            themeToggleButtons.forEach(btn => {
                if (!btn) {
                    return;
                }
                btn.addEventListener('click', () => {
                    const next = document.documentElement.dataset.theme === 'dark' ? 'light' : 'dark';
                    const applied = applyThemePreference(next);
                    persistThemePreference(applied);
                    syncThemeToggle(applied);
                    syncViewerTheme(applied);
                });
            });

            if (!getStoredThemePreference() && window.matchMedia) {
                const media = window.matchMedia('(prefers-color-scheme: dark)');
                const handler = event => {
                    if (getStoredThemePreference()) {
                        return;
                    }
                    const applied = applyThemePreference(event.matches ? 'dark' : 'light');
                    syncThemeToggle(applied);
                    syncViewerTheme(applied);
                };
                if (media.addEventListener) {
                    media.addEventListener('change', handler);
                } else if (media.addListener) {
                    media.addListener(handler);
                }
            }
        }

        function syncSidebarToggleUI() {
            if (!sidebarToggle) {
                return;
            }
            const isDrawerMode = tabletQuery.matches;
            const isOpen = sidebar && sidebar.classList.contains('open');
            if (isDrawerMode) {
                sidebarToggle.textContent = 'Library';
                sidebarToggle.setAttribute('aria-label', isOpen ? 'Close library' : 'Open library');
                sidebarToggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
                if (sidebar) {
                    sidebar.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
                }
            } else {
                sidebarToggle.textContent = sidebarHidden ? 'Show library' : 'Hide library';
                sidebarToggle.setAttribute('aria-label', sidebarHidden ? 'Show library pane' : 'Hide library pane');
                sidebarToggle.setAttribute('aria-expanded', sidebarHidden ? 'false' : 'true');
                if (sidebar) {
                    sidebar.setAttribute('aria-hidden', sidebarHidden ? 'true' : 'false');
                }
            }
            sidebarToggle.setAttribute('aria-pressed', sidebarHidden ? 'true' : 'false');
            if (libraryToggleMobile) {
                libraryToggleMobile.setAttribute('aria-label', isOpen ? 'Close library' : 'Open library');
            }
        }

        function setSidebarHidden(hidden, options = {}) {
            const { persist = true } = options;
            sidebarHidden = hidden;
            document.body.classList.toggle('sidebar-hidden', hidden);
            if (sidebar) {
                sidebar.setAttribute('aria-hidden', hidden ? 'true' : 'false');
            }
            if (hidden) {
                setSidebarOpen(false);
            }
            if (persist) {
                storeBoolean(SIDEBAR_HIDDEN_KEY, hidden);
            }
            syncSidebarToggleUI();
        }

        function applyBottomBarState() {
            const isMobile = mobileQuery.matches;
            const shouldHide = isMobile && toolsBottomBarHidden;
            document.body.classList.toggle('tools-bottom-bar-hidden', shouldHide);
            if (toolsBottomBar) {
                toolsBottomBar.setAttribute('aria-hidden', !isMobile || shouldHide ? 'true' : 'false');
            }
            if (toolsBottomBubble) {
                toolsBottomBubble.setAttribute('aria-hidden', shouldHide ? 'false' : 'true');
            }
        }

        function setBottomBarHidden(hidden, options = {}) {
            const { persist = true } = options;
            toolsBottomBarHidden = hidden;
            if (persist) {
                storeBoolean(TOOLS_BOTTOM_BAR_HIDDEN_KEY, hidden);
            }
            if (hidden && mobileQuery.matches) {
                closeToolsSheet();
            }
            applyBottomBarState();
        }

        function syncBottomBarVisibility() {
            applyBottomBarState();
        }

        function initializePaneState() {
            setSidebarHidden(sidebarHidden, { persist: false });
            setToolsPaneCollapsed(toolsPaneHidden, { persist: false });
            setBottomBarHidden(toolsBottomBarHidden, { persist: false });
            syncSidebarToggleUI();
            syncToolsPaneToggle();
            syncBottomBarVisibility();
        }

        function syncToolsPaneToggle() {
            if (!toolsSheetToggle) {
                return;
            }
            const isMobile = mobileQuery.matches;
            if (isMobile) {
                toolsSheetToggle.textContent = 'Tools';
                toolsSheetToggle.setAttribute('aria-label', 'Toggle tools panel');
                toolsSheetToggle.setAttribute('aria-expanded', document.body.classList.contains('tools-sheet-open') ? 'true' : 'false');
                return;
            }
            const isHidden = document.body.classList.contains('tools-pane-hidden');
            toolsSheetToggle.textContent = isHidden ? 'Show tools' : 'Hide tools';
            toolsSheetToggle.setAttribute('aria-label', isHidden ? 'Show tools panel' : 'Hide tools panel');
            toolsSheetToggle.setAttribute('aria-expanded', isHidden ? 'false' : 'true');
            if (toolsPane) {
                toolsPane.setAttribute('aria-hidden', isHidden ? 'true' : 'false');
            }
        }

        function setToolsPaneCollapsed(collapsed, options = {}) {
            const { persist = true } = options;
            if (!toolsPane) {
                return;
            }
            if (collapsed) {
                document.body.classList.add('tools-pane-hidden');
                toolsPane.setAttribute('aria-hidden', 'true');
                toolsPaneHidden = true;
            } else {
                document.body.classList.remove('tools-pane-hidden');
                toolsPane.setAttribute('aria-hidden', 'false');
                toolsPaneHidden = false;
            }
            if (persist) {
                storeBoolean(TOOLS_PANE_HIDDEN_KEY, collapsed);
            }
            syncToolsPaneToggle();
        }

        function toggleToolsPaneVisibility() {
            if (mobileQuery.matches) {
                return;
            }
            const isCollapsed = document.body.classList.contains('tools-pane-hidden');
            setToolsPaneCollapsed(!isCollapsed);
        }

        function openToolsSheet() {
            if (!mobileQuery.matches) {
                return;
            }
            document.body.classList.add('tools-sheet-open');
            if (toolsSheetToggle) {
                toolsSheetToggle.setAttribute('aria-expanded', 'true');
            }
            if (toolsSheetToggleMobile) {
                toolsSheetToggleMobile.setAttribute('aria-expanded', 'true');
            }
            if (toolsSheetBackdrop) {
                toolsSheetBackdrop.setAttribute('aria-hidden', 'false');
            }
            if (toolsPane) {
                toolsPane.setAttribute('aria-hidden', 'false');
            }
            syncToolsPaneToggle();
        }

        function closeToolsSheet() {
            document.body.classList.remove('tools-sheet-open');
            if (toolsSheetToggle) {
                toolsSheetToggle.setAttribute('aria-expanded', 'false');
            }
            if (toolsSheetToggleMobile) {
                toolsSheetToggleMobile.setAttribute('aria-expanded', 'false');
            }
            if (toolsSheetBackdrop) {
                toolsSheetBackdrop.setAttribute('aria-hidden', 'true');
            }
            if (toolsPane) {
                const isCollapsed = document.body.classList.contains('tools-pane-hidden');
                const shouldHide = mobileQuery.matches || isCollapsed;
                toolsPane.setAttribute('aria-hidden', shouldHide ? 'true' : 'false');
            }
            syncToolsPaneToggle();
        }

        function toggleToolsSheet() {
            if (mobileQuery.matches) {
                if (document.body.classList.contains('tools-sheet-open')) {
                    closeToolsSheet();
                } else {
                    openToolsSheet();
                }
                return;
            }
            toggleToolsPaneVisibility();
        }

        function openShortcutsModal() {
            if (!shortcutsModal || !shortcutsBackdrop) {
                return;
            }
            shortcutsModal.classList.add('visible');
            shortcutsBackdrop.classList.add('visible');
            shortcutsModal.setAttribute('aria-hidden', 'false');
            shortcutsBackdrop.setAttribute('aria-hidden', 'false');
            if (shortcutsToggle) {
                shortcutsToggle.setAttribute('aria-expanded', 'true');
            }
            document.body.classList.add('shortcuts-open');
            if (shortcutsClose) {
                shortcutsClose.focus();
            }
        }

        function closeShortcutsModal() {
            if (!shortcutsModal || !shortcutsBackdrop) {
                return;
            }
            shortcutsModal.classList.remove('visible');
            shortcutsBackdrop.classList.remove('visible');
            shortcutsModal.setAttribute('aria-hidden', 'true');
            shortcutsBackdrop.setAttribute('aria-hidden', 'true');
            if (shortcutsToggle) {
                shortcutsToggle.setAttribute('aria-expanded', 'false');
                shortcutsToggle.focus();
            }
            document.body.classList.remove('shortcuts-open');
        }

        function isTextInputTarget(target) {
            if (!target) {
                return false;
            }
            const element = target.closest ? target.closest('input, textarea, select, [contenteditable="true"]') : null;
            if (element) {
                return true;
            }
            const tag = (target.tagName || '').toLowerCase();
            return tag === 'input' || tag === 'textarea' || tag === 'select' || target.isContentEditable;
        }

        let viewerReady = false;
        let pendingFile = null;
        let currentDocumentUrl = null;
        let currentViewerSource = null;
        let bookmarkStatusTimer = null;
        let currentDocumentKey = null;

        let bookmarks = loadBookmarks();
        let lastDocument = loadLastDocument();
        let pendingAutoSave = null;
        let autoSaveTimeoutId = null;
        let autoSaveIdleCallbackId = null;
        let lastAutoSaved = { url: null, pageNumber: null };
        let ttsInitialized = false;
        let ttsPlaybackInterval = null;
        let ttsPlaybackEstimateMs = 0;
        let ttsPlaybackStart = null;
        let ttsPlaybackWordCount = 0;
        let ttsPlaybackStatusLabel = 'selection';
        let ttsOverlayLabel = 'Narration';
        let overlayPlayer = null;
        let overlayPlayerHandlers = null;
        let overlayProgressTimer = null;
        let overlayUsingFallback = false;
        let overlayScrubbing = false;
        let overlayScrubTargetSeconds = 0;
        let overlayScrubWasPlaying = false;
        let playbackAbortResolver = null;
        let playbackCancelled = false;
        let ttsPlaybackSpeed = DEFAULT_TTS_SPEED;
        let ttsNarrationSpeed = loadStoredSpeed();
        let kokoroInitPromise = null;
        let ttsStatusHideTimer = null;
        let ttsStatusProgressValue = 0;
        let currentEbook = null;
        let currentEbookRendition = null;
        let currentEbookUrl = null;
        let currentEbookLocation = null;
        let currentPageNumber = null;
        let narrationSession = null;
        let narrationSessionIdCounter = 0;
        let narrationAutoAdvanceTarget = null;
        let sidebarHidden = readStoredBoolean(SIDEBAR_HIDDEN_KEY, false);
        let toolsPaneHidden = readStoredBoolean(TOOLS_PANE_HIDDEN_KEY, false);
        let toolsBottomBarHidden = readStoredBoolean(TOOLS_BOTTOM_BAR_HIDDEN_KEY, false);
        let searchIndex = null;
        let searchDocuments = [];
        let searchActive = false;
        let searchDebounceId = null;
        let searchElementMap = new Map();
        const SEARCH_DEBOUNCE_MS = 140;

        initThemeControls();
        if (viewer) {
            viewer.addEventListener('load', () => syncViewerTheme());
        }
        initializeFileMetadata();
        updateBookmarkUI();
        updateSpeedUI();
        applySpeedToTTS();
        initializePaneState();

        function loadBookmarks() {
            try {
                const raw = window.localStorage ? localStorage.getItem(STORAGE_KEY) : null;
                if (!raw) {
                    return {};
                }
                const parsed = JSON.parse(raw);
                return sanitizeBookmarkStore(parsed);
            } catch (error) {
                console.warn('Unable to access bookmark storage:', error);
                return {};
            }
        }

        function sanitizeBookmarkStore(store) {
            const result = {};
            if (!store || typeof store !== 'object') {
                return result;
            }
            for (const [url, value] of Object.entries(store)) {
                const entry = normalizeBookmarkEntry(value);
                if (!entry) {
                    continue;
                }
                const key = normalizePDFPath(url);
                if (key) {
                    result[key] = entry;
                }
            }
            return result;
        }

        function normalizeBookmarkEntry(value) {
            if (typeof value === 'number') {
                const page = Math.floor(value);
                if (Number.isInteger(page) && page > 0) {
                    return { pageNumber: page, updatedAt: Date.now() };
                }
                return null;
            }
            if (value && typeof value === 'object') {
                const page = Math.floor(Number(value.pageNumber));
                if (Number.isInteger(page) && page > 0) {
                    const timestamp = Number.isFinite(Number(value.updatedAt)) ? Number(value.updatedAt) : Date.now();
                    return { pageNumber: page, updatedAt: timestamp };
                }
            }
            return null;
        }

        function persistBookmarks() {
            try {
                if (window.localStorage) {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(bookmarks));
                }
            } catch (error) {
                console.warn('Unable to persist bookmark:', error);
            }
        }

        function clampTtsSpeed(value) {
            const numeric = Number(value);
            if (!Number.isFinite(numeric)) {
                return DEFAULT_TTS_SPEED;
            }
            const clamped = Math.min(MAX_TTS_SPEED, Math.max(MIN_TTS_SPEED, numeric));
            const snapped = Math.round(clamped / TTS_SPEED_STEP) * TTS_SPEED_STEP;
            return Math.round(snapped * 100) / 100;
        }

        function loadStoredSpeed() {
            try {
                if (window.localStorage) {
                    const raw = localStorage.getItem(TTS_SPEED_KEY);
                    if (raw != null) {
                        return clampTtsSpeed(parseFloat(raw));
                    }
                }
            } catch (error) {
                console.warn('Unable to load narration speed preference:', error);
            }
            return DEFAULT_TTS_SPEED;
        }

        function storeTtsSpeed(value) {
            try {
                if (window.localStorage) {
                    localStorage.setItem(TTS_SPEED_KEY, String(value));
                }
            } catch (error) {
                console.warn('Unable to persist narration speed preference:', error);
            }
        }

        function formatSpeedDisplay(value) {
            const rounded = Math.round(value * 100) / 100;
            return `${rounded.toString().replace(/\\.0+$/, '').replace(/(\\.\\d*[1-9])0+$/, '$1')}√ó`;
        }

        function updateSpeedUI() {
            if (ttsSpeedSlider) {
                ttsSpeedSlider.value = (Math.round(ttsNarrationSpeed / TTS_SPEED_STEP) * TTS_SPEED_STEP).toFixed(2);
            }
            if (ttsSpeedValue) {
                ttsSpeedValue.textContent = formatSpeedDisplay(ttsNarrationSpeed);
            }
            refreshOverlayMeta();
        }

        function applySpeedToTTS() {
            if (typeof window.TTS !== 'undefined') {
                TTS.rate = ttsNarrationSpeed;
                if (TTS.kokoroSettings && typeof TTS.kokoroSettings === 'object') {
                    TTS.kokoroSettings.rate = ttsNarrationSpeed;
                }
                if (TTS.piperSettings && typeof TTS.piperSettings === 'object') {
                    TTS.piperSettings.speed = ttsNarrationSpeed;
                }
            }
        }

        function loadLastDocument() {
            try {
                const raw = window.localStorage ? localStorage.getItem(LAST_DOCUMENT_KEY) : null;
                if (!raw) {
                    return null;
                }
                const parsed = JSON.parse(raw);
                if (!parsed || typeof parsed !== 'object') {
                    return null;
                }
                const url = parsed.url ? normalizePDFPath(parsed.url) : null;
                if (!url) {
                    return null;
                }
                const page = Math.floor(Number(parsed.pageNumber));
                const updatedAt = Number.isFinite(Number(parsed.updatedAt)) ? Number(parsed.updatedAt) : Date.now();
                return {
                    url,
                    pageNumber: Number.isInteger(page) && page > 0 ? page : null,
                    updatedAt
                };
            } catch (error) {
                console.warn('Unable to load last document state:', error);
                return null;
            }
        }

        function persistLastDocument() {
            try {
                if (window.localStorage) {
                    localStorage.setItem(LAST_DOCUMENT_KEY, JSON.stringify(lastDocument));
                }
            } catch (error) {
                console.warn('Unable to persist last document state:', error);
            }
        }

        function rememberLastDocument(url, pageNumber) {
            if (!url) {
                return;
            }
            const normalizedUrl = normalizePDFPath(url);
            if (!normalizedUrl) {
                return;
            }
            const sanitizedPage = Number.isInteger(pageNumber) && pageNumber > 0 ? Math.floor(pageNumber) : null;
            lastDocument = {
                url: normalizedUrl,
                pageNumber: sanitizedPage,
                updatedAt: Date.now()
            };
            persistLastDocument();
        }

        function resolveBookmarkKey(url) {
            return url ? normalizePDFPath(url) : null;
        }

        function getBookmark(url) {
            const key = resolveBookmarkKey(url);
            return key && Object.prototype.hasOwnProperty.call(bookmarks, key) ? bookmarks[key] : undefined;
        }

        function getBookmarkPage(entry) {
            if (!entry || typeof entry !== 'object') {
                return null;
            }
            const page = Math.floor(Number(entry.pageNumber));
            return Number.isInteger(page) && page > 0 ? page : null;
        }

        function cancelPendingAutoSave() {
            if (autoSaveTimeoutId) {
                clearTimeout(autoSaveTimeoutId);
                autoSaveTimeoutId = null;
            }
            if (autoSaveIdleCallbackId && typeof window.cancelIdleCallback === 'function') {
                cancelIdleCallback(autoSaveIdleCallbackId);
                autoSaveIdleCallbackId = null;
            }
            pendingAutoSave = null;
        }

        function commitAutoSave() {
            if (!pendingAutoSave) {
                return;
            }
            const { url, pageNumber } = pendingAutoSave;
            pendingAutoSave = null;
            if (!url || !Number.isInteger(pageNumber) || pageNumber <= 0) {
                return;
            }
            const previous = getBookmark(url);
            const previousPage = getBookmarkPage(previous);
            if (previousPage === pageNumber) {
                lastAutoSaved = { url, pageNumber };
                return;
            }
            if (saveBookmark(url, pageNumber, { silent: true })) {
                lastAutoSaved = { url, pageNumber };
            }
        }

        function flushPendingAutoSave() {
            commitAutoSave();
            cancelPendingAutoSave();
        }

        function scheduleAutoSave(url, pageNumber) {
            if (!Number.isInteger(pageNumber) || pageNumber <= 0) {
                return;
            }
            const key = url ? resolveBookmarkKey(url) : currentDocumentKey;
            if (!key || key !== currentDocumentKey) {
                return;
            }
            const normalizedPage = Math.floor(pageNumber);
            if (lastAutoSaved.url === key && lastAutoSaved.pageNumber === normalizedPage) {
                return;
            }

            pendingAutoSave = { url: key, pageNumber: normalizedPage };

            if (autoSaveTimeoutId) {
                clearTimeout(autoSaveTimeoutId);
                autoSaveTimeoutId = null;
            }
            if (autoSaveIdleCallbackId && typeof window.cancelIdleCallback === 'function') {
                cancelIdleCallback(autoSaveIdleCallbackId);
                autoSaveIdleCallbackId = null;
            }

            if (typeof window.requestIdleCallback === 'function') {
                autoSaveIdleCallbackId = requestIdleCallback(() => {
                    autoSaveIdleCallbackId = null;
                    commitAutoSave();
                }, { timeout: AUTO_SAVE_IDLE_TIMEOUT_MS });
            } else {
                autoSaveTimeoutId = setTimeout(() => {
                    autoSaveTimeoutId = null;
                    commitAutoSave();
                }, AUTO_SAVE_DEBOUNCE_MS);
            }
        }

        function estimateSpeechDurationMs(text, speed = DEFAULT_TTS_SPEED) {
            const words = text.trim().split(/\\s+/).filter(Boolean).length;
            if (!words) {
                return 2000;
            }
            const wordsPerMinute = 170;
            const effectiveSpeed = clampTtsSpeed(speed || DEFAULT_TTS_SPEED);
            const adjustedWordsPerMinute = wordsPerMinute * effectiveSpeed;
            const minutes = adjustedWordsPerMinute ? (words / adjustedWordsPerMinute) : (words / wordsPerMinute);
            return Math.max(2000, minutes * 60000);
        }

        function normalizeNarrationText(raw) {
            if (!raw) {
                return '';
            }
            const withoutSoftHyphen = raw.replace(/\u00ad/g, '');
            const joinedHyphenation = withoutSoftHyphen.replace(/(\w)-\s*\n\s*(\w)/g, '$1$2');
            const collapsedLines = joinedHyphenation.replace(/\s*\n+\s*/g, ' ');
            return collapsedLines.replace(/\s{2,}/g, ' ').trim();
        }

        function splitTextIntoParagraphs(rawText) {
            if (!rawText) {
                return [];
            }
            const withoutSoftHyphen = rawText.replace(/\u00ad/g, '');
            const joinedHyphenation = withoutSoftHyphen.replace(/(\w)-\s*\n\s*(\w)/g, '$1$2');
            const normalizedNewlines = joinedHyphenation.replace(/\r\n/g, '\n');
            const trimmedNewlines = normalizedNewlines
                .replace(/[ \t]+\n/g, '\n')
                .replace(/\n[ \t]+/g, '\n');
            const paragraphs = trimmedNewlines
                .split(/\n{2,}/)
                .map(block => block.replace(/\n+/g, ' ').replace(/\s{2,}/g, ' ').trim())
                .filter(Boolean);
            if (paragraphs.length) {
                return paragraphs;
            }
            const fallback = trimmedNewlines.replace(/\n+/g, ' ').replace(/\s{2,}/g, ' ').trim();
            return fallback ? [fallback] : [];
        }

        function countWords(text) {
            if (!text) {
                return 0;
            }
            return text.trim().split(/\s+/).filter(Boolean).length;
        }

        function splitParagraphIntoFragments(paragraph, maxWords) {
            const wordCount = countWords(paragraph);
            if (!paragraph || wordCount === 0) {
                return [];
            }
            if (wordCount <= maxWords) {
                return [paragraph.trim()];
            }
            const sentences = paragraph.split(/(?<=\.)\s+/);
            if (sentences.length === 1) {
                return chunkWords(paragraph, maxWords);
            }
            const fragments = [];
            let current = '';
            for (const sentence of sentences) {
                const candidate = current ? `${current} ${sentence}` : sentence;
                if (countWords(candidate) > maxWords) {
                    if (current) {
                        fragments.push(current.trim());
                        current = sentence;
                    } else {
                        fragments.push(...chunkWords(sentence, maxWords));
                        current = '';
                    }
                } else {
                    current = candidate;
                }
            }
            if (current.trim()) {
                fragments.push(current.trim());
            }
            return fragments;
        }

        function chunkWords(text, maxWords) {
            const words = text.trim().split(/\s+/).filter(Boolean);
            if (!words.length) {
                return [];
            }
            const chunks = [];
            for (let i = 0; i < words.length; i += maxWords) {
                chunks.push(words.slice(i, i + maxWords).join(' '));
            }
            return chunks;
        }

        function buildFragmentsFromText(text, pageNumber) {
            const paragraphs = splitTextIntoParagraphs(text);
            const fragments = [];
            paragraphs.forEach(paragraph => {
                splitParagraphIntoFragments(paragraph, NARRATION_MAX_WORDS).forEach(fragment => {
                    if (fragment && fragment.trim()) {
                        const trimmed = fragment.trim();
                        fragments.push({
                            text: trimmed,
                            pageNumber,
                            estimateMs: estimateSpeechDurationMs(trimmed, ttsNarrationSpeed)
                        });
                    }
                });
            });
            return fragments;
        }

        function formatTime(seconds) {
            if (!Number.isFinite(seconds) || seconds < 0) {
                return '0:00';
            }
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function detachOverlayPlayer() {
            if (!overlayPlayer || !overlayPlayerHandlers) {
                overlayPlayer = null;
                overlayPlayerHandlers = null;
                return;
            }
            const { timeupdate, ended, pause, play, loadedmetadata } = overlayPlayerHandlers;
            overlayPlayer.removeEventListener('timeupdate', timeupdate);
            overlayPlayer.removeEventListener('ended', ended);
            overlayPlayer.removeEventListener('pause', pause);
            overlayPlayer.removeEventListener('play', play);
            overlayPlayer.removeEventListener('loadedmetadata', loadedmetadata);
            overlayPlayer = null;
            overlayPlayerHandlers = null;
        }

        function hideOverlay() {
            if (overlayProgressTimer) {
                clearInterval(overlayProgressTimer);
                overlayProgressTimer = null;
            }
            overlayScrubbing = false;
            overlayScrubTargetSeconds = 0;
            overlayScrubWasPlaying = false;
            detachOverlayPlayer();
            overlayUsingFallback = false;
            if (ttsOverlay) {
                ttsOverlay.classList.remove('show');
            }
            if (ttsOverlayProgress) {
                ttsOverlayProgress.style.width = '0%';
            }
            if (ttsOverlayTime) {
                ttsOverlayTime.textContent = '0:00 elapsed ‚Ä¢ 0:00 remaining';
            }
            ttsOverlayLabel = 'Narration';
            if (ttsOverlayTitle) {
                ttsOverlayTitle.textContent = ttsOverlayLabel;
            }
            refreshOverlayMeta();
            if (ttsOverlayPlay) {
                ttsOverlayPlay.disabled = true;
                ttsOverlayPlay.setAttribute('aria-label', 'Play narration');
                ttsOverlayPlay.dataset.state = 'paused';
            }
            if (ttsOverlayStop) {
                ttsOverlayStop.disabled = true;
            }
            if (ttsOverlayPrev) {
                ttsOverlayPrev.disabled = true;
            }
            if (ttsOverlaySkip) {
                ttsOverlaySkip.disabled = true;
            }
            if (ttsOverlayScrubber) {
                ttsOverlayScrubber.value = '0';
                ttsOverlayScrubber.max = '0';
                ttsOverlayScrubber.disabled = true;
            }
        }

        function updateOverlayProgress(percent, currentSeconds, totalSeconds) {
            const hasTotal = Number.isFinite(totalSeconds);
            const safeTotal = hasTotal ? Math.max(0, totalSeconds) : ttsPlaybackEstimateMs / 1000;
            const safeCurrent = Number.isFinite(currentSeconds) && currentSeconds > 0 ? currentSeconds : 0;
            const computedPercent = Number.isFinite(percent)
                ? percent
                : (safeTotal > 0 ? (safeCurrent / safeTotal) * 100 : 0);
            if (ttsOverlayProgress) {
                ttsOverlayProgress.style.width = `${Math.min(100, Math.max(0, computedPercent))}%`;
            }
            if (ttsOverlayTime) {
                const total = Number.isFinite(safeTotal) && safeTotal > 0 ? safeTotal : 0;
                const remaining = Math.max(0, total - safeCurrent);
                ttsOverlayTime.textContent = `${formatTime(safeCurrent)} elapsed ‚Ä¢ ${formatTime(remaining)} remaining`;
            }
            updateOverlayScrubber(safeCurrent, safeTotal);
        }

        function updateOverlayScrubber(currentSeconds, totalSeconds) {
            if (!ttsOverlayScrubber) {
                return;
            }
            const safeTotal = Number.isFinite(totalSeconds) && totalSeconds > 0 ? totalSeconds : 0;
            const safeCurrent = Number.isFinite(currentSeconds) && currentSeconds > 0 ? currentSeconds : 0;
            ttsOverlayScrubber.max = safeTotal.toFixed(2);
            if (!overlayScrubbing) {
                ttsOverlayScrubber.value = Math.min(safeCurrent, safeTotal).toFixed(2);
            }
            ttsOverlayScrubber.disabled = safeTotal <= 0;
        }

        function getFragmentEstimateMs(fragment) {
            if (!fragment) {
                return 0;
            }
            if (!fragment.estimateMs) {
                fragment.estimateMs = estimateSpeechDurationMs(fragment.text, ttsNarrationSpeed);
            }
            return fragment.estimateMs || 0;
        }

        function updateNarrationBufferEstimate(session) {
            if (!session) {
                return;
            }
            let total = 0;
            session.fragmentQueue.forEach(fragment => {
                total += getFragmentEstimateMs(fragment);
            });
            session.bufferedEstimateMs = total;
        }

        function getNarrationTotalEstimateMs(session) {
            if (!session) {
                return 0;
            }
            const currentEstimate = session.currentSegmentEstimateMs || 0;
            return session.playedMs + currentEstimate + (session.bufferedEstimateMs || 0);
        }

        function buildNarrationTimeline(session) {
            if (!session) {
                return { entries: [], totalMs: 0 };
            }
            const entries = [];
            let cursor = 0;
            const pushEntry = (fragment, kind, durationOverride) => {
                if (!fragment) {
                    return;
                }
                const durationMs = Number.isFinite(durationOverride) && durationOverride > 0
                    ? durationOverride
                    : getFragmentEstimateMs(fragment);
                entries.push({
                    fragment,
                    kind,
                    startMs: cursor,
                    endMs: cursor + durationMs,
                    durationMs
                });
                cursor += durationMs;
            };
            session.segmentHistory.forEach(fragment => {
                pushEntry(fragment, 'history', null);
            });
            const hasActiveSegment = session.currentFragment
                && (session.playbackInFlight || session.currentSegmentEstimateMs > 0 || session.currentSegmentElapsedMs > 0 || session.seekFromCurrent);
            if (hasActiveSegment) {
                pushEntry(session.currentFragment, 'current', session.currentSegmentEstimateMs || null);
            }
            session.fragmentQueue.forEach(fragment => {
                pushEntry(fragment, 'buffer', null);
            });
            return { entries, totalMs: cursor };
        }

        function rebuildNarrationCompletion(session) {
            if (!session) {
                return;
            }
            session.segmentsPlayed = session.segmentHistory.length;
            session.pagesCompleted = new Set();
            session.segmentHistory.forEach(fragment => {
                if (fragment.pageNumber && fragment.total && fragment.index === fragment.total) {
                    session.pagesCompleted.add(fragment.pageNumber);
                }
            });
        }

        function updateNarrationTimelineProgress({ elapsedMs } = {}) {
            const session = narrationSession;
            if (!session) {
                return;
            }
            const currentEstimate = session.currentSegmentEstimateMs || 0;
            let currentElapsed = Number.isFinite(elapsedMs) ? elapsedMs : session.currentSegmentElapsedMs || 0;
            if (currentEstimate > 0) {
                currentElapsed = Math.min(Math.max(0, currentElapsed), currentEstimate);
            } else {
                currentElapsed = Math.max(0, currentElapsed);
            }
            session.currentSegmentElapsedMs = currentElapsed;
            const currentMs = session.playedMs + currentElapsed;
            const totalMs = getNarrationTotalEstimateMs(session);
            if (overlayScrubbing) {
                updateOverlayScrubber(currentMs / 1000, totalMs / 1000);
            } else {
                const percent = totalMs > 0 ? (currentMs / totalMs) * 100 : 0;
                updateOverlayProgress(percent, currentMs / 1000, totalMs / 1000);
            }
            syncOverlayPrevState(session);
        }

        function recalculateNarrationEstimates() {
            const session = narrationSession;
            if (!session) {
                return;
            }
            if (session.currentFragment) {
                session.currentSegmentEstimateMs = estimateSpeechDurationMs(session.currentFragment.text, ttsNarrationSpeed);
            }
            session.fragmentQueue.forEach(fragment => {
                fragment.estimateMs = estimateSpeechDurationMs(fragment.text, ttsNarrationSpeed);
            });
            session.pageFragments.forEach(fragmentList => {
                fragmentList.forEach(fragment => {
                    fragment.estimateMs = estimateSpeechDurationMs(fragment.text, ttsNarrationSpeed);
                });
            });
            updateNarrationBufferEstimate(session);
            updateNarrationTimelineProgress({ elapsedMs: session.currentSegmentElapsedMs || 0 });
        }

        function syncOverlayPrevState(session) {
            if (!ttsOverlayPrev) {
                return;
            }
            if (!session || !session.currentFragment) {
                ttsOverlayPrev.disabled = true;
                return;
            }
            const elapsed = session.currentSegmentElapsedMs || 0;
            const hasHistory = session.segmentHistory && session.segmentHistory.length > 0;
            ttsOverlayPrev.disabled = !(hasHistory || elapsed >= 2500);
        }

        function recordCompletedFragment(session, fragment) {
            if (!session || !fragment) {
                return;
            }
            const stored = { ...fragment };
            stored.estimateMs = stored.estimateMs || getFragmentEstimateMs(stored);
            session.segmentHistory.push(stored);
            session.segmentsPlayed += 1;
            if (fragment.pageNumber && fragment.total && fragment.index === fragment.total) {
                session.pagesCompleted.add(fragment.pageNumber);
            }
        }

        function applyNarrationSeekOffset(player, session) {
            if (!session) {
                return;
            }
            const offsetMs = session.seekOffsetMs || 0;
            if (!offsetMs) {
                return;
            }
            session.seekOffsetMs = 0;
            if (!player) {
                return;
            }
            const applyOffset = () => {
                const durationMs = Number.isFinite(player.duration) && player.duration > 0
                    ? player.duration * 1000
                    : session.currentSegmentEstimateMs || 0;
                const clamped = durationMs > 0 ? Math.min(offsetMs, durationMs) : offsetMs;
                try {
                    player.currentTime = clamped / 1000;
                } catch (error) {
                    console.debug('[TTS] Unable to apply seek offset', error);
                    return;
                }
                session.currentSegmentElapsedMs = clamped;
                updateNarrationTimelineProgress({ elapsedMs: clamped });
            };
            if (player.readyState >= 1) {
                applyOffset();
            } else {
                player.addEventListener('loadedmetadata', applyOffset, { once: true });
            }
        }

        function seekNarrationToMs(targetMs, { autoplay = true } = {}) {
            const session = narrationSession;
            if (!session) {
                return;
            }
            const { entries, totalMs } = buildNarrationTimeline(session);
            if (!entries.length || totalMs <= 0) {
                return;
            }
            const clampedTarget = Math.min(Math.max(0, targetMs || 0), totalMs);
            let targetIndex = entries.findIndex(entry => clampedTarget <= entry.endMs);
            if (targetIndex < 0) {
                targetIndex = entries.length - 1;
            }
            const entry = entries[targetIndex];
            const offsetMs = Math.min(Math.max(0, clampedTarget - entry.startMs), entry.durationMs || 0);
            abortActiveSpeech({ keepOverlay: true });
            session.playbackInFlight = false;
            session.segmentHistory = entries.slice(0, targetIndex).map(entry => entry.fragment);
            session.currentFragment = entry.fragment;
            session.fragmentQueue = entries.slice(targetIndex + 1).map(entry => entry.fragment);
            session.currentSegmentEstimateMs = entry.durationMs || getFragmentEstimateMs(entry.fragment);
            session.currentSegmentElapsedMs = offsetMs;
            session.playedMs = entry.startMs;
            session.seekOffsetMs = offsetMs;
            session.seekFromCurrent = true;
            rebuildNarrationCompletion(session);
            updateNarrationBufferEstimate(session);
            updateNarrationTimelineProgress({ elapsedMs: offsetMs });
            refreshOverlayMeta();
            if (autoplay) {
                session.paused = false;
                maybeStartNarrationPlayback();
            } else {
                session.paused = true;
                setOverlayPlayState(true);
            }
        }

        function restartCurrentNarrationFragment(session) {
            if (!session || !session.currentFragment) {
                return;
            }
            session.currentSegmentElapsedMs = 0;
            session.currentSegmentEstimateMs = 0;
            session.seekOffsetMs = 0;
            session.seekFromCurrent = false;
            session.fragmentQueue.unshift(session.currentFragment);
            session.currentFragment = null;
            abortActiveSpeech({ keepOverlay: true });
            session.playbackInFlight = false;
            updateNarrationTimelineProgress({ elapsedMs: 0 });
            maybeStartNarrationPlayback();
        }

        function seekPreviousNarrationFragment() {
            const session = narrationSession;
            if (!session || !session.currentFragment) {
                return;
            }
            const elapsed = session.currentSegmentElapsedMs || 0;
            if (elapsed >= 2500) {
                restartCurrentNarrationFragment(session);
                return;
            }
            const previous = session.segmentHistory.pop();
            if (!previous) {
                restartCurrentNarrationFragment(session);
                return;
            }
            const rewindEstimate = getFragmentEstimateMs(previous);
            session.playedMs = Math.max(0, session.playedMs - rewindEstimate);
            session.currentSegmentEstimateMs = 0;
            session.currentSegmentElapsedMs = 0;
            session.seekOffsetMs = 0;
            session.seekFromCurrent = false;
            session.fragmentQueue.unshift(session.currentFragment);
            session.currentFragment = null;
            session.fragmentQueue.unshift(previous);
            abortActiveSpeech({ keepOverlay: true });
            session.playbackInFlight = false;
            rebuildNarrationCompletion(session);
            updateNarrationBufferEstimate(session);
            updateNarrationTimelineProgress({ elapsedMs: 0 });
            maybeStartNarrationPlayback();
        }

        function formatCount(value, singular, plural) {
            if (value === 1) {
                return `${value} ${singular}`;
            }
            return `${value} ${plural}`;
        }

        function refreshOverlayMeta() {
            if (!ttsOverlayMeta) {
                return;
            }
            if (!ttsOverlay || !ttsOverlay.classList.contains('show')) {
                ttsOverlayMeta.textContent = `0 words ‚Ä¢ ${formatSpeedDisplay(ttsNarrationSpeed)}`;
                if (ttsOverlayPrev) {
                    ttsOverlayPrev.disabled = true;
                }
                return;
            }
            if (narrationSession) {
                const fragment = narrationSession.currentFragment;
                const pageLabel = fragment && fragment.pageNumber ? `Page ${fragment.pageNumber}` : 'Narration';
                const parts = [pageLabel];
                if (fragment && fragment.total) {
                    parts.push(`Segment ${fragment.index}/${fragment.total}`);
                }
                const pagesPlayed = narrationSession.pagesCompleted ? narrationSession.pagesCompleted.size : 0;
                const segmentsPlayed = narrationSession.segmentsPlayed || 0;
                parts.push(formatCount(pagesPlayed, 'page played', 'pages played'));
                parts.push(formatCount(segmentsPlayed, 'segment played', 'segments played'));
                parts.push(formatCount(narrationSession.fragmentQueue.length, 'segment buffered', 'segments buffered'));
                const activeSpeed = Number.isFinite(ttsNarrationSpeed) ? ttsNarrationSpeed : ttsPlaybackSpeed;
                parts.push(formatSpeedDisplay(activeSpeed));
                ttsOverlayMeta.textContent = parts.join(' ‚Ä¢ ');
                if (ttsOverlayTitle) {
                    ttsOverlayTitle.textContent = pageLabel;
                }
                syncOverlayPrevState(narrationSession);
                return;
            }
            const wordCount = ttsPlaybackWordCount;
            const plural = wordCount === 1 ? '' : 's';
            const label = ttsOverlayLabel || '';
            const parts = [];
            if (label) {
                parts.push(label);
            }
            parts.push(`${wordCount} word${plural}`);
            const activeSpeed = Number.isFinite(ttsPlaybackSpeed) ? ttsPlaybackSpeed : ttsNarrationSpeed;
            parts.push(formatSpeedDisplay(activeSpeed));
            ttsOverlayMeta.textContent = parts.join(' ‚Ä¢ ');
            if (ttsOverlayTitle) {
                ttsOverlayTitle.textContent = label || 'Narration';
            }
            if (ttsOverlayPrev) {
                ttsOverlayPrev.disabled = true;
            }
        }

        function showOverlay(wordCount, estimateMs, speed = DEFAULT_TTS_SPEED, label = '') {
            if (!ttsOverlay) {
                return;
            }
            if (overlayProgressTimer) {
                clearInterval(overlayProgressTimer);
                overlayProgressTimer = null;
            }
            detachOverlayPlayer();
            overlayUsingFallback = true;
            ttsOverlay.classList.add('show');
            const overlayTitle = label || 'Selection';
            ttsOverlayLabel = overlayTitle;
            if (ttsOverlayTitle) {
                ttsOverlayTitle.textContent = overlayTitle;
            }
            if (ttsOverlayMeta) {
                const plural = wordCount === 1 ? '' : 's';
                const parts = [];
                if (overlayTitle) {
                    parts.push(overlayTitle);
                }
                parts.push(`${wordCount} word${plural}`);
                parts.push(formatSpeedDisplay(speed));
                ttsOverlayMeta.textContent = parts.join(' ‚Ä¢ ');
            }
            if (narrationSession) {
                updateNarrationTimelineProgress({ elapsedMs: narrationSession.currentSegmentElapsedMs || 0 });
            } else {
                updateOverlayProgress(0, 0, estimateMs / 1000);
            }
            if (ttsOverlayPlay) {
                ttsOverlayPlay.disabled = true;
                ttsOverlayPlay.setAttribute('aria-label', 'Pause narration');
                ttsOverlayPlay.dataset.state = 'playing';
            }
            if (ttsOverlayStop) {
                ttsOverlayStop.disabled = false;
            }
        }

        function setOverlayPlayState(paused) {
            if (!ttsOverlayPlay) {
                return;
            }
            ttsOverlayPlay.setAttribute('aria-label', paused ? 'Play narration' : 'Pause narration');
            ttsOverlayPlay.dataset.state = paused ? 'paused' : 'playing';
        }

        function getOverlayTotalSeconds() {
            if (narrationSession) {
                return getNarrationTotalEstimateMs(narrationSession) / 1000;
            }
            if (overlayPlayer && Number.isFinite(overlayPlayer.duration) && overlayPlayer.duration > 0) {
                return overlayPlayer.duration;
            }
            return ttsPlaybackEstimateMs ? ttsPlaybackEstimateMs / 1000 : 0;
        }

        function startOverlayScrub() {
            if (overlayScrubbing) {
                return;
            }
            overlayScrubbing = true;
            overlayScrubTargetSeconds = ttsOverlayScrubber ? Number(ttsOverlayScrubber.value) || 0 : 0;
            overlayScrubWasPlaying = false;
            if (narrationSession) {
                overlayScrubWasPlaying = !narrationSession.paused;
                if (overlayScrubWasPlaying) {
                    pauseNarration({ silent: true });
                }
                return;
            }
            if (overlayPlayer && !overlayPlayer.paused) {
                overlayScrubWasPlaying = true;
                overlayPlayer.pause();
                setOverlayPlayState(true);
            }
        }

        function updateOverlayScrubPreview(valueSeconds) {
            const totalSeconds = getOverlayTotalSeconds();
            const clamped = Math.min(Math.max(0, valueSeconds || 0), totalSeconds || valueSeconds || 0);
            const percent = totalSeconds > 0 ? (clamped / totalSeconds) * 100 : 0;
            updateOverlayProgress(percent, clamped, totalSeconds || 0);
        }

        function commitOverlayScrub() {
            if (!overlayScrubbing) {
                return;
            }
            overlayScrubbing = false;
            const totalSeconds = getOverlayTotalSeconds();
            if (!totalSeconds && !overlayScrubTargetSeconds) {
                overlayScrubTargetSeconds = 0;
                overlayScrubWasPlaying = false;
                return;
            }
            const clamped = Math.min(Math.max(0, overlayScrubTargetSeconds || 0), totalSeconds || overlayScrubTargetSeconds || 0);
            overlayScrubTargetSeconds = 0;
            if (narrationSession) {
                seekNarrationToMs(clamped * 1000, { autoplay: overlayScrubWasPlaying });
                overlayScrubWasPlaying = false;
                return;
            }
            if (overlayPlayer && Number.isFinite(overlayPlayer.duration) && overlayPlayer.duration > 0) {
                try {
                    overlayPlayer.currentTime = clamped;
                } catch (error) {
                    console.debug('[TTS] Unable to scrub player time', error);
                }
                if (!overlayScrubWasPlaying) {
                    const duration = Number.isFinite(overlayPlayer.duration) && overlayPlayer.duration > 0
                        ? overlayPlayer.duration
                        : ttsPlaybackEstimateMs / 1000;
                    const percent = duration ? (clamped / duration) * 100 : 0;
                    updateOverlayProgress(percent, clamped, duration);
                }
                if (overlayScrubWasPlaying) {
                    overlayPlayer.play().catch(err => console.debug('[TTS] Unable to resume after scrub', err));
                }
                setOverlayPlayState(!overlayScrubWasPlaying);
            }
            overlayScrubWasPlaying = false;
        }

        function attachOverlayPlayer(player) {
            if (!player) {
                return;
            }
            detachOverlayPlayer();
            overlayPlayer = player;
            overlayUsingFallback = false;
            if (ttsOverlayPlay) {
                ttsOverlayPlay.disabled = false;
                setOverlayPlayState(player.paused ? true : false);
            }
            const updateFromPlayer = () => {
                if (overlayScrubbing) {
                    return;
                }
                const current = Number.isFinite(player.currentTime) ? player.currentTime : 0;
                const duration = Number.isFinite(player.duration) && player.duration > 0 ? player.duration : ttsPlaybackEstimateMs / 1000;
                if (narrationSession) {
                    if (Number.isFinite(player.duration) && player.duration > 0) {
                        narrationSession.currentSegmentEstimateMs = player.duration * 1000;
                    }
                    updateNarrationTimelineProgress({ elapsedMs: current * 1000 });
                } else {
                    const percent = duration ? (current / duration) * 100 : 0;
                    updateOverlayProgress(percent, current, duration);
                }
            };
            const handleEnded = () => {
                setOverlayPlayState(true);
            };
            const handlePause = () => {
                setOverlayPlayState(true);
            };
            const handlePlay = () => {
                setOverlayPlayState(false);
            };
            const handleMetadata = () => {
                updateFromPlayer();
            };
            player.addEventListener('timeupdate', updateFromPlayer);
            player.addEventListener('ended', handleEnded);
            player.addEventListener('pause', handlePause);
            player.addEventListener('play', handlePlay);
            player.addEventListener('loadedmetadata', handleMetadata);
            overlayPlayerHandlers = {
                timeupdate: updateFromPlayer,
                ended: handleEnded,
                pause: handlePause,
                play: handlePlay,
                loadedmetadata: handleMetadata
            };
            updateFromPlayer();
        }

        function resolvePlaybackAbort() {
            const resolver = playbackAbortResolver;
            playbackAbortResolver = null;
            if (typeof resolver === 'function') {
                try {
                    resolver();
                } catch (error) {
                    console.debug('[TTS] Playback abort resolver threw', error);
                }
            }
        }

        function stopPlaybackProgress({ success = false, message = '', silent = false, keepOverlay = false } = {}) {
            if (ttsPlaybackInterval) {
                clearInterval(ttsPlaybackInterval);
                ttsPlaybackInterval = null;
            }
            resolvePlaybackAbort();
            if (!keepOverlay) {
                hideOverlay();
            }
            if (silent) {
                ttsPlaybackStart = null;
                ttsPlaybackEstimateMs = 0;
                ttsPlaybackWordCount = 0;
                ttsPlaybackSpeed = DEFAULT_TTS_SPEED;
                ttsPlaybackStatusLabel = 'selection';
                return;
            }
            if (message) {
                showBookmarkStatus(message);
            } else if (success) {
                const elapsedSeconds = ttsPlaybackStart ? ((performance.now() - ttsPlaybackStart) / 1000).toFixed(1) : '0.0';
                const words = ttsPlaybackWordCount;
                console.debug('[TTS] Playback finished', { elapsedSeconds, words });
                const label = ttsPlaybackStatusLabel || 'selection';
                showBookmarkStatus(`Finished reading ${label} (${elapsedSeconds}s, ${words} words)`);
            } else {
                console.debug('[TTS] Playback cancelled');
                showBookmarkStatus('Playback cancelled.');
            }
            ttsPlaybackStart = null;
            ttsPlaybackEstimateMs = 0;
            ttsPlaybackWordCount = 0;
            ttsPlaybackSpeed = DEFAULT_TTS_SPEED;
            ttsPlaybackStatusLabel = 'selection';
        }

        function startPlaybackProgress(text, estimateMs, {
            statusLabel = 'selection',
            overlayLabel = '',
            keepOverlay = false,
            elapsedOffsetMs = 0
        } = {}) {
            stopPlaybackProgress({ silent: true, keepOverlay });
            ttsPlaybackEstimateMs = estimateMs;
            const clampedOffset = Math.max(0, Math.min(elapsedOffsetMs || 0, estimateMs || 0));
            ttsPlaybackStart = performance.now() - clampedOffset;
            ttsPlaybackWordCount = text.trim().split(/\s+/).filter(Boolean).length;
            ttsPlaybackSpeed = clampTtsSpeed(ttsNarrationSpeed);
            ttsPlaybackStatusLabel = statusLabel || 'selection';
            playbackCancelled = false;
            console.debug('[TTS] Playback started', {
                words: ttsPlaybackWordCount,
                estimateMs,
                speed: ttsPlaybackSpeed,
                label: ttsPlaybackStatusLabel
            });
            const overlayTitle = overlayLabel || (ttsPlaybackStatusLabel.charAt(0).toUpperCase() + ttsPlaybackStatusLabel.slice(1));
            ttsOverlayLabel = overlayTitle;
            showOverlay(ttsPlaybackWordCount, estimateMs, ttsPlaybackSpeed, overlayTitle);

            const estimatedSeconds = (estimateMs / 1000).toFixed(1);
            const baseMessage = ttsPlaybackStatusLabel ? `Reading ${ttsPlaybackStatusLabel}‚Ä¶` : 'Reading‚Ä¶';
            showBookmarkStatus(`${baseMessage} 0% (~${estimatedSeconds}s, ${ttsPlaybackWordCount} words)`);

            ttsPlaybackInterval = setInterval(() => {
                if (!ttsPlaybackStart || !ttsPlaybackEstimateMs) {
                    return;
                }
                if (narrationSession && narrationSession.paused) {
                    return;
                }
                const elapsed = performance.now() - ttsPlaybackStart;
                const percent = Math.min(99, Math.round((elapsed / ttsPlaybackEstimateMs) * 100));
                const remainingMs = Math.max(0, ttsPlaybackEstimateMs - elapsed);
                const remainingSeconds = (remainingMs / 1000).toFixed(1);
                showBookmarkStatus(`${baseMessage} ${percent}% (~${remainingSeconds}s remaining)`);
                if (overlayUsingFallback) {
                    if (overlayScrubbing) {
                        return;
                    }
                    if (narrationSession) {
                        updateNarrationTimelineProgress({ elapsedMs: elapsed });
                    } else {
                        updateOverlayProgress(percent, elapsed / 1000, ttsPlaybackEstimateMs / 1000);
                    }
                }
            }, 300);
        }

        function collectActivePlayers() {
            const players = new Set();
            if (overlayPlayer && typeof overlayPlayer.pause === 'function') {
                players.add(overlayPlayer);
            }
            const candidate = findActiveTTSPlayer();
            if (candidate && typeof candidate.pause === 'function') {
                players.add(candidate);
            }
            if (typeof window.TTS !== 'undefined') {
                const keys = ['audio', 'currentAudio', 'player', '_audio', '_player'];
                for (const key of keys) {
                    const value = TTS[key];
                    if (value && typeof value.pause === 'function') {
                        players.add(value);
                    }
                }
                if (Array.isArray(TTS.players)) {
                    for (const value of TTS.players) {
                        if (value && typeof value.pause === 'function') {
                            players.add(value);
                        }
                    }
                }
            }
            return Array.from(players);
        }

        function abortActiveSpeech(options = {}) {
            const { keepOverlay = false } = options;
            const players = collectActivePlayers();
            players.forEach(player => {
                try {
                    if (typeof player.pause === 'function') {
                        player.pause();
                    }
                    if (typeof player.currentTime === 'number') {
                        try {
                            // Jump to end or reset time to ensure playback stops
                            player.currentTime = player.duration || 0;
                        } catch (error) {
                            console.debug('[TTS] Unable to reset audio position', error);
                        }
                    }
                    if (typeof player.stop === 'function') {
                        player.stop();
                    }
                } catch (error) {
                    console.debug('[TTS] Unable to pause player', error);
                }
            });

            stopPlaybackProgress({ silent: true, keepOverlay });

            if (typeof window.TTS !== 'undefined') {
                const stopFn = typeof TTS.stop === 'function' ? TTS.stop : (typeof TTS.cancel === 'function' ? TTS.cancel : null);
                if (stopFn) {
                    try {
                        const result = stopFn.call(TTS);
                        if (result && typeof result.then === 'function') {
                            result.catch(error => console.warn('Unable to stop active TTS session:', error));
                        }
                        console.debug('[TTS] Aborted active speech');
                    } catch (error) {
                        console.warn('Unable to stop active TTS session:', error);
                    }
                }
            }
        }

        async function ensureTTSReady() {
            if (typeof window.TTS === 'undefined') {
                console.debug('[TTS] window.TTS missing');
                setTTSStatus('Text-to-speech is unavailable in this session.', {
                    variant: 'error',
                    timeout: 6000
                });
                throw new Error('TTS library not available');
            }
            if (ttsInitialized && TTS.kokoroTtsInstance) {
                applySpeedToTTS();
                return;
            }

            TTS.TTSProvider = 'kokoro';
            TTS.rate = ttsNarrationSpeed;
            TTS.pitch = 1.0;

            if (!kokoroInitPromise) {
                console.debug('[TTS] Initializing Kokoro provider');
                setTTSButtonsBusy(true);
                setTTSStatus('Downloading voice model‚Ä¶', {
                    variant: 'info',
                    busy: true,
                    persist: true,
                    showProgress: true,
                    progress: 0
                });
                kokoroInitPromise = startKokoroInitialization();
            } else {
                setTTSButtonsBusy(true);
                setTTSStatus('Downloading voice model‚Ä¶', {
                    variant: 'info',
                    busy: true,
                    persist: true,
                    showProgress: true
                });
            }

            try {
                await kokoroInitPromise;
                if (!TTS.kokoroTtsInstance) {
                    throw new Error('Kokoro TTS instance missing after initialization.');
                }
                ttsInitialized = true;
                console.debug('[TTS] Initialization complete');
                setTTSStatus('Voice ready', {
                    variant: 'success',
                    timeout: 2400
                });
            } catch (error) {
                console.error('[TTS] Initialization failed:', error);
                setTTSStatus('Unable to load the voice. Check your connection and try again.', {
                    variant: 'error',
                    timeout: 5200
                });
                throw error;
            } finally {
                setTTSButtonsBusy(false);
                applySpeedToTTS();
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function waitForCondition(predicate, options = {}) {
            const { timeout = 60000, interval = 200 } = options;
            const start = Date.now();
            while (true) {
                try {
                    if (predicate()) {
                        return true;
                    }
                } catch (error) {
                    // Predicate may throw while dependency loads; retry until timeout.
                }
                if (Date.now() - start >= timeout) {
                    throw new Error('Timed out waiting for condition');
                }
                await delay(interval);
            }
        }

        function formatMB(bytes) {
            if (!Number.isFinite(bytes) || bytes <= 0) {
                return '0.0';
            }
            return (bytes / (1024 * 1024)).toFixed(1);
        }

        function setTTSProgressValue(value) {
            if (!ttsStatusProgressFill) {
                return;
            }
            const numeric = Number(value);
            if (!Number.isFinite(numeric)) {
                ttsStatusProgressFill.style.width = '0%';
                ttsStatusProgressValue = 0;
                return;
            }
            const clamped = Math.max(0, Math.min(100, numeric));
            ttsStatusProgressFill.style.width = `${clamped}%`;
            ttsStatusProgressValue = clamped;
        }

        function clearTTSProgress() {
            if (ttsStatusBanner) {
                ttsStatusBanner.removeAttribute('data-show-progress');
            }
            setTTSProgressValue(0);
        }

        function clearTTSStatus() {
            if (!ttsStatusBanner) {
                return;
            }
            if (ttsStatusHideTimer) {
                clearTimeout(ttsStatusHideTimer);
                ttsStatusHideTimer = null;
            }
            ttsStatusBanner.classList.remove('visible', 'busy');
            ttsStatusBanner.removeAttribute('data-variant');
            if (ttsStatusText) {
                ttsStatusText.textContent = '';
            }
            clearTTSProgress();
        }

        function setTTSStatus(message, options = {}) {
            if (!ttsStatusBanner) {
                return;
            }
            const {
                variant = 'info',
                busy = false,
                persist = false,
                timeout = null,
                showProgress = false,
                progress = null
            } = options;

            if (ttsStatusHideTimer) {
                clearTimeout(ttsStatusHideTimer);
                ttsStatusHideTimer = null;
            }

            if (!message) {
                clearTTSStatus();
                return;
            }

            if (ttsStatusText) {
                ttsStatusText.textContent = message;
            }

            ttsStatusBanner.dataset.variant = variant || 'info';

            if (busy) {
                ttsStatusBanner.classList.add('busy');
            } else {
                ttsStatusBanner.classList.remove('busy');
            }

            if (showProgress) {
                if (ttsStatusBanner) {
                    ttsStatusBanner.dataset.showProgress = 'true';
                }
                const progressValue = progress == null ? ttsStatusProgressValue : progress;
                setTTSProgressValue(progressValue);
            } else {
                clearTTSProgress();
            }

            ttsStatusBanner.classList.add('visible');

            if (!persist) {
                const fallback = variant === 'success' ? 2200 : 4200;
                const delayMs = typeof timeout === 'number' ? timeout : fallback;
                ttsStatusHideTimer = setTimeout(() => {
                    clearTTSStatus();
                }, delayMs);
            }
        }

        function setTTSButtonsBusy(isBusy) {
            const buttons = [ttsReadSelectionButton, ttsReadPageButton].filter(Boolean);
            buttons.forEach(button => {
                if (!button) {
                    return;
                }
                if (isBusy) {
                    if (!button.dataset.busySnapshot) {
                        button.dataset.busySnapshot = button.disabled ? 'disabled' : 'enabled';
                    }
                    button.disabled = true;
                    button.classList.add('is-busy');
                } else {
                    if (button.dataset.busySnapshot === 'enabled') {
                        button.disabled = false;
                    }
                    delete button.dataset.busySnapshot;
                    button.classList.remove('is-busy');
                }
            });

            if (!isBusy) {
                updateBookmarkUI();
            }
        }

        function startKokoroInitialization() {
            if (!window.TTS || typeof TTS.initKokoro !== 'function') {
                return Promise.reject(new Error('Kokoro initialization is unavailable.'));
            }

            const previousProgressHandler = typeof TTS.onKokoroDownloadProgress === 'function'
                ? TTS.onKokoroDownloadProgress
                : null;

            const handleProgress = (detail = {}) => {
                const rawTotal = Number(detail.total);
                const hasKnownTotal = Number.isFinite(rawTotal) && rawTotal > 0;
                const rawLoaded = Number(detail.loaded);
                const loadedBytes = Number.isFinite(rawLoaded) && rawLoaded >= 0 ? rawLoaded : 0;
                const estimatedTotalBytesRaw = Number(detail.estimatedTotal);
                const fallbackTotalBytes = hasKnownTotal
                    ? rawTotal
                    : (Number.isFinite(estimatedTotalBytesRaw) && estimatedTotalBytesRaw > 0
                        ? estimatedTotalBytesRaw
                        : 82 * 1024 * 1024);
                const totalBytesForDisplay = hasKnownTotal ? rawTotal : fallbackTotalBytes;
                let percent = Number(detail.percent);

                if (!Number.isFinite(percent)) {
                    percent = hasKnownTotal
                        ? (loadedBytes / rawTotal) * 100
                        : (loadedBytes / fallbackTotalBytes) * 100;
                }

                const clamped = Math.max(0, Math.min(100, percent));
                const downloadedDisplay = Math.min(Math.max(0, loadedBytes), totalBytesForDisplay);
                let message;

                if (hasKnownTotal) {
                    const downloaded = formatMB(downloadedDisplay);
                    const total = formatMB(totalBytesForDisplay);
                    message = `Downloading voice model‚Ä¶ ${clamped.toFixed(0)}% (${downloaded} / ${total} MB)`;
                } else {
                    const downloaded = formatMB(downloadedDisplay);
                    const total = formatMB(totalBytesForDisplay);
                    message = `Downloading voice model‚Ä¶ ${clamped.toFixed(0)}% (${downloaded} / ${total} MB)`;
                }

                setTTSStatus(message, {
                    variant: 'info',
                    busy: true,
                    persist: true,
                    showProgress: true,
                    progress: clamped
                });

                if (previousProgressHandler && previousProgressHandler !== handleProgress) {
                    try {
                        previousProgressHandler(detail);
                    } catch (error) {
                        console.warn('Forwarded Kokoro progress handler error:', error);
                    }
                }
            };

            TTS.onKokoroDownloadProgress = handleProgress;

            const basePromise = (async () => {
                const initResult = TTS.initKokoro();
                if (initResult && typeof initResult.then === 'function') {
                    await initResult;
                } else if (initResult === false && !TTS.kokoroTtsInstance) {
                    await waitForCondition(() => Boolean(TTS.kokoroTtsInstance));
                }

                if (!TTS.kokoroTtsInstance) {
                    await waitForCondition(() => Boolean(TTS.kokoroTtsInstance));
                }

                return true;
            })();

            const wrappedPromise = basePromise.finally(() => {
                if (typeof previousProgressHandler === 'function') {
                    TTS.onKokoroDownloadProgress = previousProgressHandler;
                } else if (TTS.onKokoroDownloadProgress === handleProgress) {
                    delete TTS.onKokoroDownloadProgress;
                }

                if (kokoroInitPromise === wrappedPromise) {
                    kokoroInitPromise = null;
                }
            });

            return wrappedPromise;
        }

        function findActiveTTSPlayer() {
            if (typeof window.TTS === 'undefined') {
                console.debug('[TTS] No window.TTS when searching for player');
                return null;
            }
            const candidates = ['audio', 'currentAudio', 'player', '_audio', '_player'];
            for (const key of candidates) {
                if (TTS[key] && typeof TTS[key].addEventListener === 'function') {
                    console.debug('[TTS] Found player via key', key);
                    return TTS[key];
                }
            }
            if (TTS && Array.isArray(TTS.players)) {
                const match = TTS.players.find(el => typeof el.addEventListener === 'function') || null;
                if (match) {
                    console.debug('[TTS] Found player via TTS.players');
                }
                return match;
            }
            const audios = document.querySelectorAll('audio');
            if (audios.length) {
                console.debug('[TTS] Using last <audio> element on page');
            }
            return audios.length ? audios[audios.length - 1] : null;
        }

        async function waitForActiveTTSPlayer({ attempts = 30, interval = 100 } = {}) {
            for (let i = 0; i < attempts; i++) {
                const player = findActiveTTSPlayer();
                if (player) {
                    return player;
                }
                await delay(interval);
            }
            console.debug('[TTS] No audio element found after waiting');
            return null;
        }

        function createPlaybackPromise(player) {
            if (!player || typeof player.addEventListener !== 'function') {
                console.debug('[TTS] No audio element available for playback promise');
                return Promise.resolve();
            }
            return new Promise(resolve => {
                let settled = false;
                const cleanup = () => {
                    if (settled) {
                        return;
                    }
                    settled = true;
                    player.removeEventListener('ended', onEnded);
                    player.removeEventListener('error', onError);
                    resolve();
                };
                const onEnded = () => {
                    console.debug('[TTS] Audio element ended');
                    cleanup();
                };
                const onError = () => {
                    console.debug('[TTS] Audio element error event');
                    cleanup();
                };
                player.addEventListener('ended', onEnded);
                player.addEventListener('error', onError);
                if (player.ended) {
                    cleanup();
                }
            });
        }

        async function speakText(text, options = {}) {
            const { ensure = true } = options;
            if (ensure) {
                await ensureTTSReady();
            }
            if (typeof TTS.stop === 'function') {
                try {
                    TTS.stop();
                } catch (error) {
                    console.warn('Unable to stop existing playback:', error);
                }
            }

            applySpeedToTTS();
            let result;
            if (TTS.TTSProvider === 'kokoro' && typeof TTS.kokoroTTS === 'function') {
                result = TTS.kokoroTTS(text);
            } else if (typeof TTS.speak === 'function') {
                result = TTS.speak(text, true);
            }

            await delay(50);

            let player = findActiveTTSPlayer();
            if (!player) {
                player = await waitForActiveTTSPlayer({ attempts: 25, interval: 120 });
            }
            console.debug('[TTS] Active audio element', player);
            let playbackPromise = Promise.resolve();

            if (player) {
                attachOverlayPlayer(player);

                console.debug('[TTS] Binding playback promise to audio element events');
                playbackPromise = createPlaybackPromise(player);
            } else {
                if (result && typeof result.then === 'function') {
                    console.debug('[TTS] Using promise returned by provider');
                    playbackPromise = result.catch(() => {});
                } else {
                    playbackPromise = Promise.resolve();
                }
                waitForActiveTTSPlayer({ attempts: 40, interval: 250 }).then(latePlayer => {
                    if (!overlayPlayer && latePlayer) {
                        console.debug('[TTS] Late audio element detected; attaching overlay');
                        attachOverlayPlayer(latePlayer);
                    }
                });
            }

            playbackPromise
                .then(() => {
                    console.debug('[TTS] Playback promise resolved');
                })
                .catch(err => {
                    console.debug('[TTS] Playback promise rejected', err);
                });

            const externalPromise = new Promise(resolve => {
                playbackAbortResolver = () => {
                    resolve();
                    playbackAbortResolver = null;
                };
            });

            const combinedPromise = Promise.race([playbackPromise, externalPromise]);
            return { player, playbackPromise: combinedPromise };
        }

        async function waitForPlaybackCompletion({ player, playbackPromise, estimateMs }) {
            const start = performance.now();
            try {
                await playbackPromise;
            } catch (error) {
                console.debug('[TTS] Playback promise rejected early', error);
            }
            const elapsed = performance.now() - start;
            const playerDurationMs = player && Number.isFinite(player.duration) && player.duration > 0
                ? player.duration * 1000
                : null;
            const targetMs = playerDurationMs || estimateMs || 0;
            if (!targetMs) {
                return;
            }
            const minTarget = Math.max(targetMs, 2000);
            const threshold = Math.min(minTarget * 0.85, Math.max(minTarget - 400, minTarget * 0.5));
            if (elapsed < threshold) {
                const remaining = Math.max(minTarget - elapsed, 800);
                console.debug('[TTS] Playback ended early; waiting fallback duration', { elapsed, remaining });
                await delay(remaining);
            }
        }

        function createNarrationSession(startPage) {
            return {
                id: ++narrationSessionIdCounter,
                documentUrl: currentDocumentUrl,
                startPage,
                nextPageToQueue: startPage,
                fragmentQueue: [],
                pageFragments: new Map(),
                pageFragmentCursor: new Map(),
                pendingPages: new Set(),
                awaitingViewer: false,
                emptyPagesSeen: 0,
                paused: false,
                playbackInFlight: false,
                currentFragment: null,
                activePlayer: null,
                pagesCompleted: new Set(),
                segmentsPlayed: 0,
                segmentHistory: [],
                playedMs: 0,
                currentSegmentEstimateMs: 0,
                currentSegmentElapsedMs: 0,
                bufferedEstimateMs: 0,
                seekOffsetMs: 0,
                seekFromCurrent: false
            };
        }

        function resolveNarrationStartPage() {
            if (Number.isInteger(currentPageNumber) && currentPageNumber > 0) {
                return currentPageNumber;
            }
            if (lastAutoSaved && Number.isInteger(lastAutoSaved.pageNumber) && lastAutoSaved.pageNumber > 0) {
                return lastAutoSaved.pageNumber;
            }
            return 1;
        }

        function setViewerPageForNarration(pageNumber) {
            if (!viewerReady || !viewer.contentWindow) {
                return;
            }
            const numericPage = Math.floor(Number(pageNumber));
            if (!Number.isInteger(numericPage) || numericPage <= 0) {
                return;
            }
            narrationAutoAdvanceTarget = numericPage;
            viewer.contentWindow.postMessage(
                { type: 'setPage', payload: { pageNumber: numericPage } },
                messageTargetOrigin
            );
        }

        function startNarrationFromCurrentPage() {
            if (!currentDocumentUrl) {
                console.debug('[TTS] Narration start ignored: no current document');
                showBookmarkStatus('Open a PDF before using read aloud.');
                return;
            }
            const startPage = resolveNarrationStartPage();
            if (!Number.isInteger(startPage) || startPage <= 0) {
                showBookmarkStatus('No page available to start narration.');
                return;
            }
            startNarrationFromPage(startPage);
        }

        function startNarrationFromPage(pageNumber) {
            stopNarration({ silent: true });
            ensureViewerLoaded();
            narrationSession = createNarrationSession(pageNumber);
            setTTSStatus('Buffering narration‚Ä¶', { busy: true });
            requestNarrationPageText(pageNumber);
            requestNarrationPageText(pageNumber + 1);
            ensureNarrationBuffer();
            maybeStartNarrationPlayback();
        }

        function requestNarrationPageText(pageNumber) {
            const session = narrationSession;
            const numericPage = Math.floor(Number(pageNumber));
            if (!session || !Number.isInteger(numericPage) || numericPage <= 0) {
                return;
            }
            if (session.pendingPages.has(numericPage) || session.pageFragments.has(numericPage)) {
                return;
            }
            session.pendingPages.add(numericPage);
            ensureViewerLoaded();
            if (!viewerReady || !viewer.contentWindow) {
                session.awaitingViewer = true;
                return;
            }
            viewer.contentWindow.postMessage(
                {
                    type: 'requestPageText',
                    payload: {
                        pageNumber: numericPage,
                        context: NARRATION_CONTEXT,
                        sessionId: session.id
                    }
                },
                messageTargetOrigin
            );
        }

        function flushPendingNarrationRequests() {
            const session = narrationSession;
            if (!session || !session.awaitingViewer || !viewerReady || !viewer.contentWindow) {
                return;
            }
            session.awaitingViewer = false;
            session.pendingPages.forEach(pageNumber => {
                viewer.contentWindow.postMessage(
                    {
                        type: 'requestPageText',
                        payload: {
                            pageNumber,
                            context: NARRATION_CONTEXT,
                            sessionId: session.id
                        }
                    },
                    messageTargetOrigin
                );
            });
        }

        function ensureNarrationBuffer() {
            const session = narrationSession;
            if (!session) {
                return;
            }
            let safetyCounter = 0;
            while (session.fragmentQueue.length < NARRATION_BUFFER_SIZE && safetyCounter < 20) {
                safetyCounter += 1;
                const pageNumber = session.nextPageToQueue;
                if (!Number.isInteger(pageNumber) || pageNumber <= 0) {
                    break;
                }
                const fragments = session.pageFragments.get(pageNumber);
                if (!fragments) {
                    requestNarrationPageText(pageNumber);
                    break;
                }
                if (fragments.length === 0) {
                    session.emptyPagesSeen += 1;
                    session.pageFragments.delete(pageNumber);
                    session.pageFragmentCursor.delete(pageNumber);
                    session.nextPageToQueue = pageNumber + 1;
                    if (session.emptyPagesSeen >= NARRATION_EMPTY_PAGE_LIMIT) {
                        stopNarration({ message: 'Reached the end of readable text.' });
                        return;
                    }
                    continue;
                }
                session.emptyPagesSeen = 0;
                const cursor = session.pageFragmentCursor.get(pageNumber) || 0;
                if (cursor >= fragments.length) {
                    session.pageFragments.delete(pageNumber);
                    session.pageFragmentCursor.delete(pageNumber);
                    session.nextPageToQueue = pageNumber + 1;
                    requestNarrationPageText(pageNumber + 1);
                    continue;
                }
                session.fragmentQueue.push(fragments[cursor]);
                session.pageFragmentCursor.set(pageNumber, cursor + 1);
                if (cursor + 1 === fragments.length) {
                    session.nextPageToQueue = pageNumber + 1;
                    requestNarrationPageText(pageNumber + 1);
                }
            }
            updateNarrationBufferEstimate(session);
            updateNarrationTimelineProgress({ elapsedMs: session.currentSegmentElapsedMs || 0 });
            refreshOverlayMeta();
        }

        function maybeStartNarrationPlayback() {
            const session = narrationSession;
            if (!session || session.playbackInFlight || session.paused) {
                return;
            }
            ensureNarrationBuffer();
            if (!session.fragmentQueue.length && !(session.seekFromCurrent && session.currentFragment)) {
                setTTSStatus('Buffering next section‚Ä¶', { busy: true });
                return;
            }
            if (ttsOverlaySkip) {
                ttsOverlaySkip.disabled = false;
            }
            clearTTSStatus();
            playNextNarrationFragment();
        }

        async function playNextNarrationFragment() {
            const session = narrationSession;
            if (!session || session.playbackInFlight || session.paused) {
                return;
            }
            session.playbackInFlight = true;
            const useCurrent = session.seekFromCurrent && session.currentFragment;
            const fragment = useCurrent ? session.currentFragment : session.fragmentQueue.shift();
            if (!fragment) {
                session.playbackInFlight = false;
                maybeStartNarrationPlayback();
                return;
            }
            session.seekFromCurrent = false;
            session.currentFragment = fragment;
            const estimateMs = session.currentSegmentEstimateMs && session.currentSegmentEstimateMs > 0
                ? session.currentSegmentEstimateMs
                : getFragmentEstimateMs(fragment);
            session.currentSegmentEstimateMs = estimateMs;
            const seekOffsetMs = session.seekOffsetMs || 0;
            session.currentSegmentElapsedMs = seekOffsetMs ? Math.min(seekOffsetMs, estimateMs) : 0;
            updateNarrationBufferEstimate(session);
            refreshOverlayMeta();
            updateNarrationTimelineProgress({ elapsedMs: session.currentSegmentElapsedMs });
            if (Number.isInteger(fragment.pageNumber) && fragment.pageNumber > 0 && fragment.pageNumber !== currentPageNumber) {
                setViewerPageForNarration(fragment.pageNumber);
            }
            try {
                await ensureTTSReady();
                const overlayLabel = fragment.pageNumber ? `Page ${fragment.pageNumber}` : 'Page';
                startPlaybackProgress(fragment.text, estimateMs, {
                    statusLabel: fragment.pageNumber ? `page ${fragment.pageNumber}` : 'page',
                    overlayLabel,
                    keepOverlay: true,
                    elapsedOffsetMs: session.currentSegmentElapsedMs
                });
                const { playbackPromise, player } = await speakText(fragment.text, { ensure: false });
                session.activePlayer = player;
                applyNarrationSeekOffset(player, session);
                await waitForPlaybackCompletion({ player, playbackPromise, estimateMs });
                stopPlaybackProgress({ silent: true, keepOverlay: true });
            } catch (error) {
                console.error('[TTS] Narration fragment failed:', error);
                stopNarration({ message: 'Unable to continue narration.' });
                return;
            }
            if (!narrationSession || narrationSession.id !== session.id) {
                return;
            }
            if (session.currentFragment !== fragment) {
                session.playbackInFlight = false;
                return;
            }
            session.activePlayer = null;
            session.playbackInFlight = false;
            fragment.estimateMs = session.currentSegmentEstimateMs || fragment.estimateMs;
            session.playedMs += session.currentSegmentEstimateMs || 0;
            session.currentSegmentEstimateMs = 0;
            session.currentSegmentElapsedMs = 0;
            session.seekOffsetMs = 0;
            recordCompletedFragment(session, fragment);
            updateNarrationTimelineProgress({ elapsedMs: 0 });
            refreshOverlayMeta();
            if (session.paused) {
                return;
            }
            ensureNarrationBuffer();
            maybeStartNarrationPlayback();
        }

        function pauseNarration(options = {}) {
            const { silent = false } = options;
            const session = narrationSession;
            if (!session || session.paused) {
                return;
            }
            session.paused = true;
            const players = collectActivePlayers();
            players.forEach(player => {
                try {
                    player.pause();
                } catch (error) {
                    console.debug('[TTS] Unable to pause player', error);
                }
            });
            setOverlayPlayState(true);
            if (!silent) {
                showBookmarkStatus('Narration paused.');
            }
        }

        function resumeNarration() {
            const session = narrationSession;
            if (!session || !session.paused) {
                return;
            }
            session.paused = false;
            if (overlayPlayer && overlayPlayer.paused) {
                overlayPlayer.play().catch(err => console.debug('[TTS] Unable to resume playback', err));
                setOverlayPlayState(false);
                return;
            }
            maybeStartNarrationPlayback();
        }

        function toggleNarrationPlayPause() {
            if (!narrationSession) {
                if (overlayPlayer) {
                    try {
                        if (overlayPlayer.paused) {
                            overlayPlayer.play().catch(err => console.debug('[TTS] Unable to resume playback', err));
                        } else {
                            overlayPlayer.pause();
                        }
                    } catch (error) {
                        console.debug('[TTS] Play/pause toggle failed', error);
                    }
                    return;
                }
                startNarrationFromCurrentPage();
                return;
            }
            if (narrationSession.paused || (overlayPlayer && overlayPlayer.paused)) {
                resumeNarration();
            } else {
                pauseNarration();
            }
        }

        function skipNarrationFragment() {
            const session = narrationSession;
            if (!session) {
                return;
            }
            const fragment = session.currentFragment;
            session.playedMs += session.currentSegmentEstimateMs || 0;
            session.currentSegmentEstimateMs = 0;
            session.currentSegmentElapsedMs = 0;
            session.seekOffsetMs = 0;
            session.seekFromCurrent = false;
            if (fragment) {
                fragment.estimateMs = fragment.estimateMs || getFragmentEstimateMs(fragment);
                recordCompletedFragment(session, fragment);
            }
            session.currentFragment = null;
            session.playbackInFlight = false;
            session.paused = false;
            abortActiveSpeech({ keepOverlay: true });
            updateNarrationTimelineProgress({ elapsedMs: 0 });
            ensureNarrationBuffer();
            maybeStartNarrationPlayback();
        }

        function stopNarration(options = {}) {
            const { silent = false, message = '' } = options;
            const hadSession = Boolean(narrationSession);
            narrationSession = null;
            narrationAutoAdvanceTarget = null;
            abortActiveSpeech();
            if (ttsOverlaySkip) {
                ttsOverlaySkip.disabled = true;
            }
            if (!silent && hadSession) {
                showBookmarkStatus(message || 'Narration stopped.');
            }
            clearTTSStatus();
        }

        function handleNarrationPageText(payload) {
            const session = narrationSession;
            if (!session || !payload) {
                return;
            }
            if (payload.sessionId != null && payload.sessionId !== session.id) {
                return;
            }
            const payloadUrl = payload.url ? normalizePDFPath(payload.url) : null;
            if (payloadUrl && session.documentUrl && payloadUrl !== session.documentUrl) {
                return;
            }
            const pageNumberRaw = payload.pageNumber;
            const pageNumber = Number.isFinite(Number(pageNumberRaw)) ? Math.max(1, Math.floor(Number(pageNumberRaw))) : null;
            if (!pageNumber) {
                return;
            }
            session.pendingPages.delete(pageNumber);
            const payloadError = payload.error ? String(payload.error) : null;
            const rawText = (payload.text ? String(payload.text) : '').trim();
            if (!rawText) {
                if (payloadError) {
                    console.debug('[TTS] Viewer reported page extraction error:', payloadError);
                }
                session.pageFragments.set(pageNumber, []);
                session.pageFragmentCursor.set(pageNumber, 0);
                ensureNarrationBuffer();
                maybeStartNarrationPlayback();
                return;
            }
            const fragments = buildFragmentsFromText(rawText, pageNumber);
            if (!fragments.length) {
                session.pageFragments.set(pageNumber, []);
                session.pageFragmentCursor.set(pageNumber, 0);
                ensureNarrationBuffer();
                maybeStartNarrationPlayback();
                return;
            }
            fragments.forEach((fragment, index) => {
                fragment.index = index + 1;
                fragment.total = fragments.length;
            });
            session.pageFragments.set(pageNumber, fragments);
            session.pageFragmentCursor.set(pageNumber, 0);
            requestNarrationPageText(pageNumber + 1);
            ensureNarrationBuffer();
            maybeStartNarrationPlayback();
        }

        function handleNarrationPageChange(pageNumber, sourceUrl) {
            const session = narrationSession;
            if (!session) {
                return;
            }
            const normalizedSource = sourceUrl ? normalizePDFPath(sourceUrl) : null;
            if (normalizedSource && session.documentUrl && normalizedSource !== session.documentUrl) {
                return;
            }
            if (narrationAutoAdvanceTarget && pageNumber === narrationAutoAdvanceTarget) {
                narrationAutoAdvanceTarget = null;
                return;
            }
            if (!session.currentFragment) {
                return;
            }
            if (session.currentFragment && session.currentFragment.pageNumber === pageNumber) {
                return;
            }
            // Manual scrolling should not stop narration.
        }

        function requestSelectionPlayback() {
            if (!currentDocumentUrl) {
                console.debug('[TTS] Read request ignored: no current document');
                showBookmarkStatus('Open a PDF before using read aloud.');
                return;
            }
            stopNarration({ silent: true });
            ensureViewerLoaded();
            if (!viewerReady || !viewer.contentWindow) {
                console.debug('[TTS] Viewer not ready for selection playback', {
                    viewerReady,
                    hasContentWindow: Boolean(viewer && viewer.contentWindow)
                });
                showBookmarkStatus('Viewer is still loading. Try again shortly.');
                return;
            }
            console.debug('[TTS] Requesting selection text from viewer');
            viewer.contentWindow.postMessage(
                { type: 'requestSelectionText' },
                messageTargetOrigin
            );
        }

        function requestPagePlayback() {
            startNarrationFromCurrentPage();
        }

        async function handleSelectionText(payload) {
            const rawText = (payload && payload.text ? String(payload.text) : '').trim();
            const payloadUrl = payload && payload.url ? normalizePDFPath(payload.url) : null;
            if (payloadUrl && currentDocumentUrl && payloadUrl !== currentDocumentUrl) {
                console.debug('[TTS] Selection payload ignored due to document mismatch', {
                    payloadUrl,
                    currentDocumentUrl
                });
                return;
            }
            if (!rawText) {
                showBookmarkStatus('Select some text first.');
                return;
            }
            const normalizedText = normalizeNarrationText(rawText);
            if (!normalizedText) {
                showBookmarkStatus('Select some text first.');
                return;
            }
            console.debug('[TTS] Received selection payload', {
                length: normalizedText.length,
                preview: normalizedText.slice(0, 80),
                pageNumber: payload && payload.pageNumber
            });
            try {
                abortActiveSpeech();
                await ensureTTSReady();
                const estimateMs = estimateSpeechDurationMs(normalizedText, ttsNarrationSpeed);
                const selectionPage = payload && Number.isFinite(Number(payload.pageNumber))
                    ? Math.max(1, Math.floor(Number(payload.pageNumber)))
                    : null;
                const overlayLabel = selectionPage ? `Selection (Page ${selectionPage})` : 'Selection';
                startPlaybackProgress(normalizedText, estimateMs, {
                    statusLabel: 'selection',
                    overlayLabel
                });
                const { playbackPromise, player } = await speakText(normalizedText, { ensure: false });
                await waitForPlaybackCompletion({ player, playbackPromise, estimateMs });
                stopPlaybackProgress({ success: true });
            } catch (error) {
                console.error('TTS playback failed:', error);
                setTTSStatus('Unable to read the selected text right now.', {
                    variant: 'error',
                    timeout: 5200
                });
                stopPlaybackProgress({ success: false, message: 'Unable to read selection right now.' });
            }
        }

        function setSidebarOpen(open) {
            if (!sidebar) {
                return;
            }
            if (open && sidebarHidden) {
                setSidebarHidden(false);
            }
            if (sidebarHidden) {
                open = false;
            }
            if (open) {
                sidebar.classList.add('open');
                if (sidebarBackdrop) {
                    sidebarBackdrop.classList.add('visible');
                }
                if (sidebarToggle) {
                    sidebarToggle.classList.add('active');
                    sidebarToggle.setAttribute('aria-expanded', 'true');
                }
            } else {
                sidebar.classList.remove('open');
                if (sidebarBackdrop) {
                    sidebarBackdrop.classList.remove('visible');
                }
                if (sidebarToggle) {
                    sidebarToggle.classList.remove('active');
                    sidebarToggle.setAttribute('aria-expanded', 'false');
                }
            }
            syncSidebarToggleUI();
        }

        function handleViewportChange(event) {
            if (event.matches) {
                setSidebarOpen(false);
            } else {
                setSidebarOpen(false);
                if (sidebarBackdrop) {
                    sidebarBackdrop.classList.remove('visible');
                }
                closeToolsSheet();
            }
            syncToolsPaneToggle();
            syncSidebarToggleUI();
            syncBottomBarVisibility();
        }

        function handleMobileQueryChange() {
            closeToolsSheet();
            syncToolsPaneToggle();
            syncBottomBarVisibility();
            syncSidebarToggleUI();
        }

        if (sidebarToggle) {
            sidebarToggle.addEventListener('click', () => {
                if (tabletQuery.matches) {
                    if (sidebarHidden) {
                        setSidebarHidden(false);
                        setSidebarOpen(true);
                        return;
                    }
                    const isOpen = sidebar.classList.contains('open');
                    setSidebarOpen(!isOpen);
                    return;
                }
                setSidebarHidden(!sidebarHidden);
            });
        }

        if (libraryToggleMobile) {
            libraryToggleMobile.addEventListener('click', () => {
                if (!tabletQuery.matches) {
                    setSidebarHidden(!sidebarHidden);
                    return;
                }
                if (sidebarHidden) {
                    setSidebarHidden(false);
                    setSidebarOpen(true);
                    return;
                }
                const isOpen = sidebar.classList.contains('open');
                setSidebarOpen(!isOpen);
            });
        }

        if (sidebarBackdrop) {
            sidebarBackdrop.addEventListener('click', () => setSidebarOpen(false));
            sidebarBackdrop.setAttribute('aria-hidden', 'true');
        }

        if (toolsSheetToggle) {
            toolsSheetToggle.addEventListener('click', toggleToolsSheet);
        }

        if (toolsSheetToggleMobile) {
            toolsSheetToggleMobile.addEventListener('click', toggleToolsSheet);
        }

        if (toolsSheetBackdrop) {
            toolsSheetBackdrop.addEventListener('click', closeToolsSheet);
        }

        if (toolsBottomBarHide) {
            toolsBottomBarHide.addEventListener('click', () => setBottomBarHidden(true));
        }

        if (toolsBottomBubble) {
            toolsBottomBubble.addEventListener('click', () => setBottomBarHidden(false));
        }

        if (shortcutsToggle) {
            shortcutsToggle.addEventListener('click', () => openShortcutsModal());
        }

        if (shortcutsClose) {
            shortcutsClose.addEventListener('click', () => closeShortcutsModal());
        }

        if (shortcutsBackdrop) {
            shortcutsBackdrop.addEventListener('click', () => closeShortcutsModal());
        }

        if (tabletQuery.addEventListener) {
            tabletQuery.addEventListener('change', handleViewportChange);
        } else if (tabletQuery.addListener) {
            tabletQuery.addListener(handleViewportChange);
        }

        if (mobileQuery.addEventListener) {
            mobileQuery.addEventListener('change', handleMobileQueryChange);
        } else if (mobileQuery.addListener) {
            mobileQuery.addListener(handleMobileQueryChange);
        }

        function handleGlobalKeydown(event) {
            if (!event) {
                return;
            }
            if (event.key === 'Escape') {
                if (shortcutsModal && shortcutsModal.classList.contains('visible')) {
                    closeShortcutsModal();
                    return;
                }
                setSidebarOpen(false);
                closeToolsSheet();
                return;
            }
            if (shortcutsModal && shortcutsModal.classList.contains('visible')) {
                return;
            }
            if (event.ctrlKey || event.metaKey || event.altKey) {
                return;
            }
            if (isTextInputTarget(event.target)) {
                return;
            }
            const key = event.key ? event.key.toLowerCase() : '';
            if (key === 'l') {
                event.preventDefault();
                if (sidebarToggle) {
                    sidebarToggle.click();
                }
                return;
            }
            if (key === 't') {
                event.preventDefault();
                toggleToolsSheet();
                return;
            }
            if (key === 'h' || event.key === '?') {
                event.preventDefault();
                openShortcutsModal();
            }
        }

        document.addEventListener('keydown', handleGlobalKeydown);

        function normalizePDFPath(path) {
            if (!path) {
                return null;
            }
            if (!/^https?:\/\//i.test(path)) {
                return path;
            }
            try {
                const url = new URL(path);
                if (url.hostname !== 'github.com') {
                    return path;
                }
                const segments = url.pathname.split('/').filter(Boolean);
                const rawIndex = segments.indexOf('raw');
                if (rawIndex === -1) {
                    return path;
                }
                const owner = segments[0];
                const repo = segments[1];
                if (!owner || !repo) {
                    return path;
                }
                let branch;
                let fileSegments;
                const nextSegment = segments[rawIndex + 1];
                if (nextSegment === 'refs' && segments[rawIndex + 2] === 'heads') {
                    branch = segments[rawIndex + 3];
                    fileSegments = segments.slice(rawIndex + 4);
                } else {
                    branch = nextSegment;
                    fileSegments = segments.slice(rawIndex + 2);
                }
                if (!branch || !fileSegments.length) {
                    return path;
                }
                return `https://media.githubusercontent.com/media/${owner}/${repo}/${branch}/${fileSegments.join('/')}`;
            } catch (error) {
                return path;
            }
        }

        function ensureViewerLoaded() {
            if (!viewer.src) {
                viewer.src = 'viewer/viewer.html';
            }
        }

        function postOpenRequest(request) {
            if (!viewer.contentWindow) {
                return;
            }
            const payload = typeof request === 'string' ? { url: request } : request;
            viewer.contentWindow.postMessage(
                { type: 'openFile', payload },
                messageTargetOrigin
            );
        }

        function sendOpenRequest(options = {}) {
            if (!currentViewerSource) {
                return;
            }
            ensureViewerLoaded();
            const request = { url: currentViewerSource };
            if (options && options.pageNumber != null) {
                const pageNumber = Number(options.pageNumber);
                if (Number.isFinite(pageNumber) && pageNumber > 0) {
                    request.pageNumber = Math.floor(pageNumber);
                }
            }
            if (viewerReady && viewer.contentWindow) {
                postOpenRequest(request);
            } else {
                pendingFile = { ...request };
            }
        }

        function updateBookmarkUI() {
            const hasDocument = Boolean(currentDocumentUrl);
            const bookmarkEntry = hasDocument ? getBookmark(currentDocumentUrl) : null;
            const hasBookmark = getBookmarkPage(bookmarkEntry) !== null;
            if (bookmarkSaveButton) {
                bookmarkSaveButton.disabled = !hasDocument;
            }
            if (bookmarkResumeButton) {
                bookmarkResumeButton.disabled = !hasBookmark;
            }
            if (bookmarkClearButton) {
                bookmarkClearButton.disabled = !hasBookmark;
            }
            if (ttsReadSelectionButton) {
                ttsReadSelectionButton.disabled = !hasDocument;
            }
            if (ttsReadPageButton) {
                ttsReadPageButton.disabled = !hasDocument;
            }
            if (quickBookmarkSave) {
                quickBookmarkSave.disabled = !hasDocument;
            }
            if (quickBookmarkResume) {
                quickBookmarkResume.disabled = !hasBookmark;
            }
            if (quickTtsSelection) {
                quickTtsSelection.disabled = !hasDocument;
            }
            if (quickTtsPage) {
                quickTtsPage.disabled = !hasDocument;
            }
            if (hasDocument) {
                const hasStatus = bookmarkEntry && getBookmarkPage(bookmarkEntry) !== null;
                if (bookmarkControls) {
                    bookmarkControls.setAttribute('aria-live', 'polite');
                }
                syncSidebarToggleUI();
            }
        }

        function showBookmarkStatus(message) {
            if (!bookmarkStatus) {
                return;
            }
            if (bookmarkStatusTimer) {
                clearTimeout(bookmarkStatusTimer);
                bookmarkStatusTimer = null;
            }
            if (message) {
                bookmarkStatus.textContent = message;
                bookmarkStatus.classList.add('visible');
                bookmarkStatusTimer = setTimeout(() => {
                    bookmarkStatus.textContent = '';
                    bookmarkStatus.classList.remove('visible');
                }, 4000);
            } else {
                bookmarkStatus.textContent = '';
                bookmarkStatus.classList.remove('visible');
            }
        }

        function saveBookmark(url, pageNumber, options = {}) {
            const { silent = false } = options;
            const key = resolveBookmarkKey(url);
            if (!key || !Number.isInteger(pageNumber) || pageNumber <= 0) {
                return false;
            }
            const normalizedPage = Math.floor(pageNumber);
            bookmarks[key] = {
                pageNumber: normalizedPage,
                updatedAt: Date.now()
            };
            persistBookmarks();
            rememberLastDocument(key, normalizedPage);
            updateBookmarkUI();
            lastAutoSaved = { url: key, pageNumber: normalizedPage };
            if (!silent) {
                showBookmarkStatus(`Bookmark saved at page ${normalizedPage}`);
            }
            return true;
        }

        function clearBookmark(url) {
            const key = resolveBookmarkKey(url);
            if (!key || !Object.prototype.hasOwnProperty.call(bookmarks, key)) {
                return false;
            }
            delete bookmarks[key];
            persistBookmarks();
            rememberLastDocument(key, null);
            updateBookmarkUI();
            if (lastAutoSaved.url === key) {
                lastAutoSaved = { url: key, pageNumber: null };
            }
            if (currentDocumentKey === key) {
                cancelPendingAutoSave();
            }
            return true;
        }

        function requestCurrentPage() {
            if (!viewerReady || !viewer.contentWindow || !currentViewerSource) {
                showBookmarkStatus('Open the PDF before bookmarking.');
                return;
            }
            viewer.contentWindow.postMessage(
                { type: 'requestCurrentPage', payload: { url: currentViewerSource } },
                messageTargetOrigin
            );
        }

        function handleBookmarkMessage(payload) {
            if (!payload) {
                return;
            }
            const rawPage = Math.floor(Number(payload.pageNumber));
            if (!Number.isInteger(rawPage) || rawPage <= 0) {
                return;
            }
            const sourceUrl = payload.url || currentViewerSource;
            if (sourceUrl && currentViewerSource && sourceUrl !== currentViewerSource) {
                return;
            }
            if (!currentDocumentUrl) {
                return;
            }
            currentPageNumber = rawPage;
            saveBookmark(currentDocumentUrl, rawPage);
        }

        function handleAutoSaveMessage(payload) {
            if (!payload) {
                return;
            }
            const rawPage = Math.floor(Number(payload.pageNumber));
            const sourceUrl = payload.url || currentDocumentUrl;
            if (!Number.isInteger(rawPage) || rawPage <= 0) {
                return;
            }
            if (!currentDocumentKey) {
                return;
            }
            currentPageNumber = rawPage;
            scheduleAutoSave(sourceUrl, rawPage);
            handleNarrationPageChange(rawPage, sourceUrl);
        }

        function initializeFileMetadata() {
            document.querySelectorAll('.file').forEach((element) => {
                const onclickValue = element.getAttribute('onclick') || '';
                const match = onclickValue.match(/loadPDF\('(.*?)'/);
                if (!match) {
                    return;
                }
                const originalPath = match[1];
                const normalized = normalizePDFPath(originalPath);
                if (!normalized) {
                    return;
                }
                const viewerPath = normalized.startsWith('http') ? normalized : normalized.replace(/^\/+/, '');
                element.dataset.pdfUrl = normalized;
                element.dataset.viewerPath = viewerPath;
            });
        }

        function getFileTitleForElement(element) {
            if (!element) {
                return '';
            }
            const label = element.querySelector('span:not(.file-icon)') || element;
            return (label.textContent || '').trim();
        }

        function getCategoryLabelForElement(element) {
            if (!element) {
                return '';
            }
            const category = element.closest('.category');
            if (!category) {
                return '';
            }
            const headerLabel = category.querySelector(':scope > .category-header span:not(.category-icon)');
            return headerLabel ? headerLabel.textContent.trim() : '';
        }

        function getSubcategoryPathForElement(element) {
            if (!element || !fileTree) {
                return '';
            }
            const labels = [];
            let current = element.parentElement;
            while (current && current !== fileTree) {
                if (current.classList.contains('file-list')) {
                    const header = current.previousElementSibling;
                    if (header && header.classList.contains('subcategory-header')) {
                        const text = header.textContent.trim();
                        if (text) {
                            labels.push(text);
                        }
                    }
                }
                if (current.classList.contains('category-content')) {
                    break;
                }
                current = current.parentElement;
            }
            return labels.reverse().join(' / ');
        }

        function buildSearchDocuments() {
            if (!fileTree) {
                return [];
            }
            searchElementMap = new Map();
            const docs = [];
            const fileElements = Array.from(fileTree.querySelectorAll('.file'));
            fileElements.forEach((element, index) => {
                const id = element.dataset.searchId || `file-${index}`;
                element.dataset.searchId = id;
                searchElementMap.set(id, element);
                const title = getFileTitleForElement(element);
                const category = getCategoryLabelForElement(element);
                const subcategory = getSubcategoryPathForElement(element);
                const searchText = [title, category, subcategory].filter(Boolean).join(' ').toLowerCase();
                docs.push({
                    id,
                    title,
                    category,
                    subcategory,
                    searchText
                });
            });
            return docs;
        }

        function createSearchIndex(docs) {
            if (window.MiniSearch) {
                const miniSearch = new MiniSearch({
                    fields: ['title', 'category', 'subcategory'],
                    storeFields: ['title', 'category', 'subcategory']
                });
                miniSearch.addAll(docs);
                return { type: 'mini', engine: miniSearch };
            }
            return { type: 'fallback', docs };
        }

        function updateSearchStatusText(count, query) {
            if (!searchStatus) {
                return;
            }
            if (!query) {
                searchStatus.textContent = 'Type to filter the library.';
                return;
            }
            if (!count) {
                searchStatus.textContent = `No matches for \"${query}\".`;
                return;
            }
            searchStatus.textContent = `${count} match${count === 1 ? '' : 'es'}`;
        }

        function updateSearchClearButton(query) {
            if (!searchClearButton) {
                return;
            }
            searchClearButton.classList.toggle('visible', Boolean(query));
        }

        function snapshotSearchState() {
            if (!fileTree) {
                return;
            }
            fileTree.querySelectorAll('.category-content, .file-list').forEach((element) => {
                element.dataset.searchOpen = element.classList.contains('open') ? 'true' : 'false';
            });
            fileTree.querySelectorAll('.category-header').forEach((header) => {
                const icon = header.querySelector('.category-icon');
                if (icon) {
                    icon.dataset.searchIcon = icon.textContent;
                }
            });
        }

        function restoreSearchState() {
            if (!fileTree) {
                return;
            }
            fileTree.querySelectorAll('.category-content, .file-list').forEach((element) => {
                const wasOpen = element.dataset.searchOpen === 'true';
                element.classList.toggle('open', wasOpen);
                delete element.dataset.searchOpen;
            });
            fileTree.querySelectorAll('.category-header').forEach((header) => {
                const icon = header.querySelector('.category-icon');
                if (icon && icon.dataset.searchIcon) {
                    icon.textContent = icon.dataset.searchIcon;
                    delete icon.dataset.searchIcon;
                }
            });
        }

        function markSearchNode(node, shouldOpen = false) {
            if (!node) {
                return;
            }
            node.classList.remove('search-hidden');
            node.classList.add('search-match');
            if (shouldOpen) {
                node.classList.add('open');
            }
        }

        function revealSearchMatch(element) {
            if (!element || !fileTree) {
                return;
            }
            markSearchNode(element);
            let parent = element.parentElement;
            while (parent && parent !== fileTree) {
                if (parent.classList.contains('file-list')) {
                    markSearchNode(parent, true);
                    const header = parent.previousElementSibling;
                    if (header && header.classList.contains('subcategory-header')) {
                        markSearchNode(header);
                    }
                }
                if (parent.classList.contains('category-content')) {
                    markSearchNode(parent, true);
                    const header = parent.previousElementSibling;
                    if (header && header.classList.contains('category-header')) {
                        markSearchNode(header);
                        updateCategoryIcon(header, true);
                    }
                }
                if (parent.classList.contains('category') || parent.classList.contains('subcategory')) {
                    markSearchNode(parent);
                }
                parent = parent.parentElement;
            }
        }

        function clearSearchFilter() {
            if (!fileTree) {
                return;
            }
            fileTree.querySelectorAll('.search-hidden, .search-match').forEach((element) => {
                element.classList.remove('search-hidden', 'search-match');
            });
            if (searchActive) {
                document.body.classList.remove('search-active');
                restoreSearchState();
                searchActive = false;
            }
        }

        function applySearchResults(matchIds) {
            if (!fileTree) {
                return;
            }
            if (!searchActive) {
                snapshotSearchState();
                document.body.classList.add('search-active');
                searchActive = true;
            }
            const nodes = fileTree.querySelectorAll('.category, .category-header, .category-content, .subcategory, .subcategory-header, .file-list, .file');
            nodes.forEach((node) => {
                node.classList.remove('search-match');
                node.classList.add('search-hidden');
            });
            matchIds.forEach((id) => {
                const element = searchElementMap.get(id);
                if (element) {
                    revealSearchMatch(element);
                }
            });
        }

        function runSearch(rawQuery) {
            if (!searchIndex) {
                return;
            }
            const query = (rawQuery || '').trim();
            updateSearchClearButton(query);
            if (!query) {
                clearSearchFilter();
                updateSearchStatusText(0, '');
                return;
            }
            let results = [];
            if (searchIndex.type === 'mini') {
                results = searchIndex.engine.search(query, { prefix: true });
            } else {
                const normalized = query.toLowerCase();
                results = searchIndex.docs.filter(doc => doc.searchText.includes(normalized));
            }
            const matchIds = new Set(results.map(result => result.id));
            applySearchResults(matchIds);
            updateSearchStatusText(matchIds.size, query);
        }

        function initializeSearch() {
            if (!searchInput || !fileTree) {
                return;
            }
            searchDocuments = buildSearchDocuments();
            searchIndex = createSearchIndex(searchDocuments);
            updateSearchStatusText(0, '');
            updateSearchClearButton(searchInput.value.trim());

            searchInput.addEventListener('input', () => {
                if (searchDebounceId) {
                    clearTimeout(searchDebounceId);
                }
                searchDebounceId = setTimeout(() => {
                    runSearch(searchInput.value);
                }, SEARCH_DEBOUNCE_MS);
            });

            searchInput.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    event.preventDefault();
                    event.stopPropagation();
                    searchInput.value = '';
                    runSearch('');
                    searchInput.blur();
                }
            });

            if (searchClearButton) {
                searchClearButton.addEventListener('click', () => {
                    searchInput.value = '';
                    runSearch('');
                    searchInput.focus();
                });
            }

            runSearch(searchInput.value);
        }

        function findFileElementByUrl(url) {
            if (!url) {
                return null;
            }
            const normalized = normalizePDFPath(url);
            if (!normalized) {
                return null;
            }
            return Array.from(document.querySelectorAll('.file')).find(el => el.dataset.pdfUrl === normalized) || null;
        }

        function updateCategoryIcon(header, isOpen) {
            if (!header) {
                return;
            }
            const icon = header.querySelector('.category-icon');
            if (icon) {
                icon.textContent = isOpen ? 'üìÇ' : 'üìÅ';
            }
        }

        function expandParents(element) {
            let parent = element ? element.parentElement : null;
            while (parent) {
                if (parent.classList.contains('file-list')) {
                    parent.classList.add('open');
                    const header = parent.previousElementSibling;
                    if (header && header.classList.contains('subcategory-header')) {
                        header.classList.add('open');
                    }
                }
                if (parent.classList.contains('category-content')) {
                    parent.classList.add('open');
                    const categoryHeader = parent.previousElementSibling;
                    if (categoryHeader && categoryHeader.classList.contains('category-header')) {
                        updateCategoryIcon(categoryHeader, true);
                    }
                }
                parent = parent.parentElement;
            }
        }

        function clearSelections() {
            document.querySelectorAll('.file, .external-link').forEach(el => el.classList.remove('selected'));
        }

        function selectFileElement(element) {
            clearSelections();
            if (element) {
                element.classList.add('selected');
                expandParents(element);
            }
        }

        function selectExternalElement(element) {
            clearSelections();
            if (element) {
                element.classList.add('selected');
                expandParents(element);
            }
        }

        function teardownEbook() {
            try {
                if (currentEbookRendition && typeof currentEbookRendition.destroy === 'function') {
                    currentEbookRendition.destroy();
                }
            } catch (error) {
                console.debug('[ebook] Unable to destroy rendition', error);
            }
            try {
                if (currentEbook && typeof currentEbook.destroy === 'function') {
                    currentEbook.destroy();
                }
            } catch (error) {
                console.debug('[ebook] Unable to destroy book', error);
            }
            currentEbook = null;
            currentEbookRendition = null;
            currentEbookUrl = null;
            currentEbookLocation = null;
            if (ebookContainer) {
                ebookContainer.innerHTML = '';
            }
            if (ebookTitle) {
                ebookTitle.textContent = 'eBook viewer';
            }
            if (ebookStatus) {
                ebookStatus.textContent = 'Select an EPUB or MOBI link';
            }
            if (ebookPrev) {
                ebookPrev.disabled = true;
            }
            if (ebookNext) {
                ebookNext.disabled = true;
            }
            if (ebookViewer) {
                ebookViewer.style.display = 'none';
            }
        }

        window.addEventListener('message', (event) => {
            if (!isFileProtocol && event.origin !== window.location.origin) {
                return;
            }
            const { type, payload } = event.data || {};
            if (!type) {
                return;
            }
            if (type === 'viewerReady') {
                viewerReady = true;
                syncViewerTheme();
                if (pendingFile) {
                    postOpenRequest(pendingFile);
                    pendingFile = null;
                }
                flushPendingNarrationRequests();
                maybeStartNarrationPlayback();
                return;
            }
            if (type === 'currentPage') {
                handleBookmarkMessage(payload);
                return;
            }
            if (type === 'selectionText') {
                handleSelectionText(payload);
                return;
            }
            if (type === 'pageText') {
                if (payload && payload.context === NARRATION_CONTEXT) {
                    handleNarrationPageText(payload);
                }
                return;
            }
            if (type === 'pageChanged') {
                handleAutoSaveMessage(payload);
            }
        });

        function openDocument(path, triggerElement, options = {}) {
            const normalizedPath = normalizePDFPath(path);
            if (!normalizedPath) {
                return;
            }
            const viewerPath = normalizedPath.startsWith('http') ? normalizedPath : normalizedPath.replace(/^\/+/, '');

            flushPendingAutoSave();
            stopNarration({ silent: true });
            teardownEbook();

            if (externalViewer) {
                externalViewer.style.display = 'none';
                try {
                    externalViewer.src = 'about:blank';
                } catch (error) {
                    console.debug('[external] Unable to clear external viewer', error);
                }
            }

            currentDocumentUrl = normalizedPath;
            currentDocumentKey = resolveBookmarkKey(normalizedPath) || normalizedPath;
            currentViewerSource = viewerPath;

            selectFileElement(triggerElement || findFileElementByUrl(currentDocumentUrl));

            placeholder.style.display = 'none';
            viewer.style.display = 'block';

            if (tabletQuery.matches) {
                setSidebarOpen(false);
            }

            const requestedPage = options && options.pageNumber != null ? Math.floor(Number(options.pageNumber)) : null;
            const bookmarkEntry = getBookmark(currentDocumentUrl);
            const savedPage = getBookmarkPage(bookmarkEntry);
            const targetPage = Number.isInteger(requestedPage) && requestedPage > 0 ? requestedPage : savedPage;

            lastAutoSaved = { url: currentDocumentKey, pageNumber: targetPage || null };
            currentPageNumber = targetPage || null;
            rememberLastDocument(currentDocumentUrl, targetPage);
            updateBookmarkUI();
            showBookmarkStatus('');

            sendOpenRequest(targetPage != null ? { pageNumber: targetPage } : {});
        }

        function isPdfLikeUrl(url) {
            if (!url) {
                return false;
            }
            try {
                const normalized = String(url).split('#')[0].toLowerCase();
                return normalized.includes('.pdf');
            } catch (error) {
                return /\.pdf/i.test(url);
            }
        }

        function isEpubLikeUrl(url) {
            if (!url) {
                return false;
            }
            try {
                const normalized = String(url).split('#')[0].toLowerCase();
                return normalized.endsWith('.epub');
            } catch (error) {
                return /\.epub(?:$|\?|\#)/i.test(url);
            }
        }

        function isMobiLikeUrl(url) {
            if (!url) {
                return false;
            }
            try {
                const normalized = String(url).split('#')[0].toLowerCase();
                return normalized.endsWith('.mobi');
            } catch (error) {
                return /\.mobi(?:$|\?|\#)/i.test(url);
            }
        }

        function isEbookLikeUrl(url) {
            return isEpubLikeUrl(url) || isMobiLikeUrl(url);
        }

        function openExternalResource(url, triggerElement) {
            const target = (url || '').trim();
            if (!target) {
                return;
            }
            if (isEbookLikeUrl(target)) {
                openEbookResource(target, triggerElement);
                return;
            }
            if (isPdfLikeUrl(target)) {
                openDocument(target, triggerElement);
                return;
            }

            flushPendingAutoSave();
            stopNarration({ silent: true });
            teardownEbook();

            currentDocumentUrl = null;
            currentDocumentKey = null;
            currentViewerSource = null;
            pendingFile = null;

            selectExternalElement(triggerElement || null);

            placeholder.style.display = 'none';
            if (viewer) {
                viewer.style.display = 'none';
            }
            if (externalViewer) {
                externalViewer.style.display = 'block';
                try {
                    externalViewer.src = target;
                } catch (error) {
                    console.warn('[external] Unable to load external URL', target, error);
                }
            }

            if (tabletQuery.matches) {
                setSidebarOpen(false);
            }

            updateBookmarkUI();
            showBookmarkStatus('');
        }

        async function openEbookResource(url, triggerElement) {
            const target = (url || '').trim();
            if (!target) {
                return;
            }
            const normalizedPath = normalizePDFPath(target) || target;
            const isMobi = isMobiLikeUrl(normalizedPath);

            flushPendingAutoSave();
            stopNarration({ silent: true });

            currentDocumentUrl = null;
            currentDocumentKey = null;
            currentViewerSource = null;
            pendingFile = null;

            selectExternalElement(triggerElement || null);
            teardownEbook();

            if (viewer) {
                viewer.style.display = 'none';
            }
            if (externalViewer) {
                externalViewer.style.display = 'none';
                try {
                    externalViewer.src = 'about:blank';
                } catch (error) {
                    console.debug('[external] Unable to clear external viewer', error);
                }
            }

            placeholder.style.display = 'none';

            if (isMobi) {
                if (externalViewer) {
                    const gviewUrl = `https://docs.google.com/gview?embedded=1&url=${encodeURIComponent(normalizedPath)}`;
                    externalViewer.style.display = 'block';
                    try {
                        externalViewer.src = gviewUrl;
                    } catch (error) {
                        console.warn('[mobi] Unable to load MOBI via external viewer', error);
                    }
                }
                showBookmarkStatus('MOBI files open in an external viewer (may be limited).');
                updateBookmarkUI();
                return;
            }

            if (!ebookViewer || !ebookContainer) {
                showBookmarkStatus('EPUB viewer unavailable.');
                return;
            }

            if (typeof window.ePub !== 'function') {
                if (ebookStatus) {
                    ebookStatus.textContent = 'epub.js did not load; check your network.';
                }
                ebookViewer.style.display = 'flex';
                updateBookmarkUI();
                return;
            }

            ebookViewer.style.display = 'flex';
            if (ebookStatus) {
                ebookStatus.textContent = 'Loading EPUB...';
            }
            if (ebookTitle) {
                ebookTitle.textContent = 'eBook viewer';
            }

            try {
                currentEbookUrl = normalizedPath;
                currentEbook = window.ePub(normalizedPath);
                currentEbookRendition = currentEbook.renderTo(ebookContainer, {
                    width: '100%',
                    height: '100%',
                    spread: 'always'
                });

                const updateEbookStatus = (location) => {
                    if (!ebookStatus) {
                        return;
                    }
                    if (location && typeof location.start?.percentage === 'number') {
                        const pct = Math.min(100, Math.max(0, Math.round(location.start.percentage * 100)));
                        ebookStatus.textContent = `Progress: ${pct}%`;
                    } else {
                        ebookStatus.textContent = 'Use Next/Prev or arrow keys';
                    }
                };

                currentEbookRendition.on('relocated', (location) => {
                    currentEbookLocation = location;
                    updateEbookStatus(location);
                });

                currentEbookRendition.on('rendered', () => {
                    if (ebookPrev) {
                        ebookPrev.disabled = false;
                    }
                    if (ebookNext) {
                        ebookNext.disabled = false;
                    }
                });

                await currentEbook.ready;
                const metaTitle = currentEbook?.package?.metadata?.title;
                if (ebookTitle) {
                    ebookTitle.textContent = metaTitle || 'EPUB';
                }
                if (currentEbookRendition) {
                    await currentEbookRendition.display();
                }
                updateEbookStatus(currentEbookLocation || null);
            } catch (error) {
                console.warn('[ebook] Unable to open EPUB', error);
                teardownEbook();
                if (ebookStatus) {
                    ebookStatus.textContent = 'Failed to open EPUB; try downloading instead.';
                }
                if (placeholder) {
                    placeholder.style.display = 'flex';
                }
            } finally {
                updateBookmarkUI();
            }
        }

        function loadResource(path, triggerElement, options = {}) {
            const target = (path || '').trim();
            if (!target) {
                return;
            }
            if (isEbookLikeUrl(target)) {
                openEbookResource(target, triggerElement);
                return;
            }
            if (isPdfLikeUrl(target)) {
                openDocument(target, triggerElement, options);
                return;
            }
            openExternalResource(target, triggerElement);
        }

        if (bookmarkSaveButton) {
            bookmarkSaveButton.addEventListener('click', () => {
                if (!currentDocumentUrl) {
                    return;
                }
                requestCurrentPage();
            });
        }

        if (bookmarkResumeButton) {
            bookmarkResumeButton.addEventListener('click', () => {
                if (!currentDocumentUrl) {
                    return;
                }
                const entry = getBookmark(currentDocumentUrl);
                const savedPage = getBookmarkPage(entry);
                if (!Number.isInteger(savedPage) || savedPage <= 0) {
                    showBookmarkStatus('No bookmark saved for this PDF.');
                    return;
                }
                rememberLastDocument(currentDocumentUrl, savedPage);
                lastAutoSaved = { url: currentDocumentKey, pageNumber: savedPage };
                sendOpenRequest({ pageNumber: savedPage });
                showBookmarkStatus(`Opening bookmark at page ${savedPage}`);
            });
        }

        if (bookmarkClearButton) {
            bookmarkClearButton.addEventListener('click', () => {
                if (!currentDocumentUrl) {
                    return;
                }
                const entry = getBookmark(currentDocumentUrl);
                if (!getBookmarkPage(entry)) {
                    showBookmarkStatus('No bookmark to clear.');
                    return;
                }
                if (clearBookmark(currentDocumentUrl)) {
                    showBookmarkStatus('Bookmark cleared.');
                }
            });
        }

        if (quickBookmarkSave) {
            quickBookmarkSave.addEventListener('click', () => {
                if (!quickBookmarkSave.disabled) {
                    requestCurrentPage();
                }
            });
        }

        if (quickBookmarkResume) {
            quickBookmarkResume.addEventListener('click', () => {
                if (!quickBookmarkResume.disabled && bookmarkResumeButton) {
                    bookmarkResumeButton.click();
                }
            });
        }

        if (ttsSpeedSlider) {
            ttsSpeedSlider.addEventListener('input', event => {
                const value = clampTtsSpeed(parseFloat(event.target.value));
                const changed = value !== ttsNarrationSpeed;
                ttsNarrationSpeed = value;
                updateSpeedUI();
                if (changed) {
                    storeTtsSpeed(ttsNarrationSpeed);
                }
                applySpeedToTTS();
                if (ttsPlaybackStart) {
                    ttsPlaybackSpeed = value;
                }
                refreshOverlayMeta();
                recalculateNarrationEstimates();
            });
        }

        if (ttsReadSelectionButton) {
            ttsReadSelectionButton.addEventListener('click', () => {
                if (!ttsReadSelectionButton.disabled) {
                    requestSelectionPlayback();
                }
            });
        }

        if (ttsReadPageButton) {
            ttsReadPageButton.addEventListener('click', () => {
                if (!ttsReadPageButton.disabled) {
                    requestPagePlayback();
                }
            });
        }

        if (quickTtsSelection) {
            quickTtsSelection.addEventListener('click', () => {
                if (!quickTtsSelection.disabled) {
                    requestSelectionPlayback();
                }
            });
        }

        if (quickTtsPage) {
            quickTtsPage.addEventListener('click', () => {
                if (!quickTtsPage.disabled) {
                    requestPagePlayback();
                }
            });
        }

        if (ebookPrev) {
            ebookPrev.addEventListener('click', () => {
                if (currentEbookRendition && typeof currentEbookRendition.prev === 'function') {
                    currentEbookRendition.prev();
                }
            });
        }

        if (ebookNext) {
            ebookNext.addEventListener('click', () => {
                if (currentEbookRendition && typeof currentEbookRendition.next === 'function') {
                    currentEbookRendition.next();
                }
            });
        }

        if (ttsOverlayPlay) {
            ttsOverlayPlay.addEventListener('click', () => {
                toggleNarrationPlayPause();
            });
        }

        if (ttsOverlayPrev) {
            ttsOverlayPrev.addEventListener('click', () => {
                seekPreviousNarrationFragment();
            });
        }

        if (ttsOverlaySkip) {
            ttsOverlaySkip.addEventListener('click', () => {
                skipNarrationFragment();
            });
        }

        if (ttsOverlayStop) {
            ttsOverlayStop.addEventListener('click', () => {
                console.debug('[TTS] Stop button pressed');
                stopNarration({ message: 'Playback cancelled.' });
            });
        }

        if (ttsOverlayScrubber) {
            ttsOverlayScrubber.addEventListener('pointerdown', () => {
                startOverlayScrub();
            });
            ttsOverlayScrubber.addEventListener('input', () => {
                if (!overlayScrubbing) {
                    startOverlayScrub();
                }
                overlayScrubTargetSeconds = Number(ttsOverlayScrubber.value) || 0;
                updateOverlayScrubPreview(overlayScrubTargetSeconds);
            });
            ttsOverlayScrubber.addEventListener('pointerup', () => {
                commitOverlayScrub();
            });
            ttsOverlayScrubber.addEventListener('change', () => {
                commitOverlayScrub();
            });
        }

        function restoreLastDocument() {
            if (!lastDocument || !lastDocument.url) {
                return false;
            }
            const normalizedUrl = normalizePDFPath(lastDocument.url);
            if (!normalizedUrl) {
                return false;
            }
            const entry = getBookmark(normalizedUrl);
            const savedPage = lastDocument.pageNumber != null ? lastDocument.pageNumber : getBookmarkPage(entry);
            const fileElement = findFileElementByUrl(normalizedUrl);
            openDocument(normalizedUrl, fileElement || null, savedPage != null ? { pageNumber: savedPage } : {});
            return true;
        }

        function sendInitialBookmarkState() {
            updateBookmarkUI();
        }

        sendInitialBookmarkState();
        hideOverlay();

        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                flushPendingAutoSave();
            }
        });

        window.addEventListener('beforeunload', () => {
            flushPendingAutoSave();
        });

        window.addEventListener('load', () => {
            initializeSearch();
            setSidebarOpen(false);
            const restored = restoreLastDocument();
            if (!restored) {
                const firstCategory = document.querySelector('.category-header');
                if (firstCategory) {
                    firstCategory.click();
                }
            }
        });

        window.toggleCategory = toggleCategory;
        window.toggleSubcategory = toggleSubcategory;
        window.loadPDF = loadResource;
        window.loadExternal = openExternalResource;
        window.loadResource = loadResource;
    </script>
</body>
</html>
